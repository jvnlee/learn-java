# 람다식 (Lambda Expression)

`JDK` 1.8부터 람다식이 추가되면서 `Java`는 객체지향 언어인 동시에 함수형 언어가 됨.

&nbsp;

## 람다식이란?

메서드를 하나의 식(expression)으로 표현한 것.

메서드의 이름과 반환 타입이 사라지기 때문에 <b>익명 함수</b>라고 부르기도 함.

&nbsp;

람다식의 이점:

- 클래스와 객체 생성 없이 메서드를 사용할 수 있음

- 메서드를 다른 메서드의 매개변수나 반환값으로 사용할 수 있음

&nbsp;

## 람다식 작성하기

기존 메서드 형태에서 이름과 반환 타입을 제거하고 선언부와 몸통 사이에 `->` 추가

```java
int max(int a, int b) {
    return a > b ? a : b;
}
```

```java
(int a, int b) -> { return a > b ? a : b; }
```

반환값이 있는 메서드는 `return`문 대신 식(expression)으로 대체 가능

```java
(int a, int b) -> a > b ? a : b
```

선언된 매개 변수의 타입이 추론 가능한 경우는 타입 생략 가능

> 반환 타입이 없는 이유도 추론이 가능하기 때문

```java
(a, b) -> a > b ? a : b
```

매개 변수가 하나인 경우는 감싸고 있는 괄호 `()` 생략 가능

```java
a -> a + 1
// (a) -> a + 1
```

메서드의 몸통 안에 문장이 하나인 경우는 중괄호 `{}` 생략 가능

```java
(String name, int age) -> {
    System.out.printf("My name is %s, and I'm %d years old.", name, age);
}
```

```java
(String name, int age) -> System.out.printf("My name is %s, and I'm %d years old.", name, age)
```

> 이 때 문장 뒤에 붙이는 `;`은 떼어야함

&nbsp;

## 함수형 인터페이스 (Functional Interface)

람다식이 메서드와 동등한 것으로 설명되었지만, 사실은 익명 클래스의 객체와 동등함.

```java
(int a, int b) -> a > b ? a : b
```

```java
new Object() {
    int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

따라서 람다식을 클래스나 인터페이스 타입의 참조변수에 담는 것을 생각해볼 수 있는데,

`Java`에서는 람다식을 담을 그릇으로 인터페이스를 활용하는 것을 규칙으로 함.

선언부가 동일한 추상 메서드를 인터페이스에 담고,

```java
interface MyFunction {
    public abstract int max(int a, int b);
}
```

익명 객체를 생성해 인터페이스를 구현한 다음,

```java
MyFunction f = new MyFunction {
    public int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

익명 객체를 람다식으로 치환하면

```java
MyFunction f = (int a, int b) -> a > b ? a : b;
```

이렇게 하나의 메서드가 선언된 인터페이스를 정의해서 람다식을 다루는 것이 기존 설계와 어긋나지 않고 자연스럽기 때문에 인터페이스를 활용해 람다식을 다루기로 결정됨.

그리고 람다식을 다루기 위한 인터페이스를 <b>함수형 인터페이스</b>라고 부름.

함수형 인터페이스에는 단 하나의 추상 메서드만 정의되어 있어야함.

> 그래야 람다식과 1대 1 대응이 될 수 있기 때문

&nbsp;

`@FunctionalInterface` 애너테이션을 붙이면 함수형 인터페이스를 선언할 때 컴파일러가 위 제약 조건을 체크해줌.

```java
@FunctionalInterface
interface MyFunction {
    public abstract int max(int a, int b);
}
```

&nbsp;

### 함수형 인터페이스 타입의 매개변수와 반환 타입

메서드의 매개 변수 타입이 함수형 인터페이스 타입이면, 메서드 호출 시

```java
@FunctionalInterface
interface MyFunction {
    public abstract int add(int a, int b);
}

class Dummy {
    int a, b;

    int someMethod(MyFunction f) {
        f.add(a, b);
    }
}
```

1. 람다식을 참조하는 참조 변수를 인자로 넘기거나,

```java
MyFunction func = (a, b) -> a + b;
```

```java
someMethod(func);
```

2. 람다식 자체를 인자로 넘길 수 있음

```java
someMethod((a, b) -> a + b);
```

&nbsp;

메서드의 반환 타입이 함수형 인터페이스 타입이면

1. 람다식을 참조하는 참조 변수를 반환하거나,

```java
MyFunction someMethod() {
    MyFunction f = (a, b) -> a + b;
    return f;
}
```

2. 람다식 자체를 반환할 수 있음

```java
MyFunction someMethod() {
    return (a, b) -> a + b;
}
```

&nbsp;

### 람다식의 타입과 형변환

함수형 인터페이스 타입의 참조 변수로 람다식을 참조할 수 있지만, 람다식의 타입이 함수형 인터페이스의 타입과 일치하는 것은 아님.

람다식은 익명 객체이기 때문에 타입을 알 수 없음.

> 익명 객체의 타입은 컴파일러가 임의로 정하기 때문에 프로그래머는 모름.

그래서 엄밀히는 형변환이 필요함.

```java
@FunctionalInterface
interface MyFunction {
    void printName(String name);
}
```

```java
MyFunction f = (MyFunction)((String name) -> System.out.println(name));
```

람다식이 `MyFunction`을 직접 구현한 건 아니지만 구현한 클래스의 객체와 동일하기 때문에 허용되는 형변환임.

이 형변환은 생략 가능.

&nbsp;

람다식은 객체이지만 `Object` 타입으로는 형변환이 불가능.

오직 함수형 인터페이스로만 형변환이 가능

> 굳이 `Object` 타입으로 만들고 싶다면 먼저 함수형 인터페이스로 형변환 시킨뒤 `Object` 타입으로 형변환시키면 됨.

&nbsp;

### 외부 변수를 참조하는 람다식

람다식에서 외부 변수에 접근하는 규칙은 익명 클래스의 것과 동일.

람다식이 지역 변수를 참조하게 되면, 해당 지역 변수는 `final`이 없더라도 모두 상수로 간주됨. (값 변경 불가능해짐)

```java
@FunctionalInterface
interface MyFunction {
    void myLambda();
}

class LambdaExample {
    public static void main(String[] args) {
        Outer o = new Outer();
        Outer.Inner i = o.new Inner();
        i.innerMethod(7777);
    }
}

class Outer {
    int outerVar = 777;

    class Inner {
        int innerVar = 77;

        void innerMethod(int param) {
            int innerLocalVar = 7;
            // 람다식이 param을 참조하고 있으므로 param += 1 처럼 값을 변경할 수 없음.

            MyFunction f = () -> {
                System.out.println("innerLocalVar: " + innerLocalVar);
                System.out.println("innerVar: " + innerVar);
                System.out.println("outerVar: " + outerVar);
                System.out.println("param: " + param);
            };

            f.myLambda();
        }
    }
}
```

실행 결과)

    innerLocalVar: 7
    innerVar: 77
    outerVar: 777
    param: 7777

이 예제의 경우에는 람다식이 참조하고 있는 지역 변수 `innerLocalVar`가 상수로 간주됨.

또한 함수의 파라미터도 지역 변수이고, 람다식에서 참조하고 있으므로 `param` 역시 값의 수정이 불가능한 상수로 취급됨.

> `innerLocalVar`나 `param`의 값을 변경하는 문장을 넣고 컴파일 하면 에러 발생
>
>       java: local variables referenced from a lambda expression must be final or effectively final
