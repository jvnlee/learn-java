# ìŠ¤íŠ¸ë¦¼ (Stream)

## ìŠ¤íŠ¸ë¦¼ì´ë€?

ì§€ê¸ˆê¹Œì§€ëŠ” ë§ì€ ì–‘ì˜ ë°ì´í„°ë¥¼ ë‹¤ë£° ë•Œ, ë°°ì—´ì´ë‚˜ ì»¬ë ‰ì…˜ì— ë°ì´í„°ë¥¼ ë‹´ì•„ `for`ë¬¸ì´ë‚˜ `Iterator`ë¥¼ í™œìš©í•´ì™”ìŒ.

- ê¸¸ì–´ì§€ëŠ” ì½”ë“œ, ë‚®ì€ ì¬ì‚¬ìš©ì„±

- ë°ì´í„° ì†ŒìŠ¤ë§ˆë‹¤ ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ ë‹¤ë£¨ì–´ì•¼í•¨

`Collection`ê³¼ `Iterator` ì¸í„°í˜ì´ìŠ¤ë¡œ ì»¬ë ‰ì…˜ì„ ë‹¤ë£¨ëŠ” ë°©ì‹ì´ í‘œì¤€í™”ë˜ê¸´ í–ˆìœ¼ë‚˜, ì‹¤ì œë¡œ í˜¸ì¶œí•  ë•ŒëŠ” ê°™ì€ ì´ë¦„ê³¼ ê¸°ëŠ¥ì„ ê°€ì§„ ë©”ì„œë“œë¥¼ ê°ê¸° ë‹¤ë¥¸ ë°©ì‹ìœ¼ë¡œ í˜¸ì¶œí•´ì•¼í•¨.

> `List` ì •ë ¬: `Collections.sort()`
>
> ë°°ì—´ ì •ë ¬: `Arrays.sort()`

<b>ìŠ¤íŠ¸ë¦¼(Stream)</b>ì€ ì´ëŸ° ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„œ ë§Œë“¤ì–´ì§

- ë°ì´í„° ì†ŒìŠ¤ë¥¼ ì¶”ìƒí™”

- ë°ì´í„°ë¥¼ ë‹¤ë£¨ëŠ”ë°ì— ìì£¼ ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œë¥¼ ì •ì˜

> ì†ŒìŠ¤ê°€ ë¬´ì—‡ì´ë˜ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë‹¤ë£° ìˆ˜ ìˆê²Œ ë¨. ë†’ì€ ì¬ì‚¬ìš©ì„±

&nbsp;

ex)

ë¬¸ìì—´ ë°°ì—´ê³¼ ë¬¸ìì—´ ë¦¬ìŠ¤íŠ¸ê°€ ìˆì„ ë•Œ

```java
String[] strArr = {"aaa", "bbb", "ccc"};
List<String> strList = Arrays.asList(strArr);
```

ê°ê°ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ë©´ ë‹¤ìŒê³¼ ê°™ìŒ.

```java
Stream<String> strStream1 = Arrays.stream(strArr);
Stream<String> strStream2 = strList.stream();
```

ì´ 2ê°€ì§€ ë¬¸ìì—´ ìŠ¤íŠ¸ë¦¼ì—ì„œ ë°ì´í„°ë¥¼ ì •ë ¬í•´ì„œ ì¶œë ¥í•˜ëŠ” ë°©ì‹ì€ ê°™ìŒ.

```java
strStream1.sorted().forEach(System.out::println);
strStream2.sorted().forEach(System.out::println);
```

> ìŠ¤íŠ¸ë¦¼ ì—†ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¥í™©í•œ ì½”ë“œë¥¼ ì¼ì–´ì•¼í•¨
>
> ```java
> Arrays.sort(strArr);
> Collections.sort(strList);
>
> for (String str : strArr) {
>     System.out.println(str);
> }
>
> for (String str : strList) {
>     System.out.println(str);
> }
> ```

### ìŠ¤íŠ¸ë¦¼ì€ ë°ì´í„° ì†ŒìŠ¤ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤

ì›ë³¸ì„ ë³€ê²½ì‹œí‚¤ì§€ ì•Šìœ¼ë¯€ë¡œ, ì •ë ¬ëœ ê²°ê³¼ ë“±ì„ ì–»ìœ¼ë ¤ë©´ ìƒˆë¡œìš´ ì»¬ë ‰ì…˜ì´ë‚˜ ë°°ì—´ì— ë‹´ì•„ì•¼í•¨.

ex) `strStream2`ë¥¼ ì •ë ¬í•œ ê²°ê³¼ë¥¼ ìƒˆ ë¦¬ìŠ¤íŠ¸ì¸ `sortedList`ì— ë‹´ìŒ

```java
List<String> sortedList = strStream2.sorted().collect(Collectors.toList());
```

&nbsp;

### ìŠ¤íŠ¸ë¦¼ì€ ì¼íšŒìš©ì´ë‹¤

í•œ ë²ˆ ìˆœíšŒë¥¼ ë§ˆì¹œ `Iterator`ëŠ” ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ì—†ë“¯ì´, ìŠ¤íŠ¸ë¦¼ë„ í•œë²ˆ ì“°ê³  ë‚˜ë©´ ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ.

ìŠ¤íŠ¸ë¦¼ì´ ë˜ í•„ìš”í•˜ë©´ ë‹¤ì‹œ ìƒì„±í•´ì„œ ì‚¬ìš©.

ex)

```java
strStream1.sorted().forEach(System.out::println); // ìŠ¤íŠ¸ë¦¼ ì‚¬ìš© ì™„ë£Œ
int numOfStr = strStream1.count(); // (X) ì´ë¯¸ ì‚¬ìš©í•œ ìŠ¤íŠ¸ë¦¼ì„ ë˜ ì“¸ ìˆœ ì—†ìŒ
```

&nbsp;

### ìŠ¤íŠ¸ë¦¼ì€ ì‘ì—…ì„ ë‚´ë¶€ ë°˜ë³µìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤

ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•œ í‘œí˜„ì´ í›¨ì”¬ ê°„ê²°í•œ ì´ìœ ëŠ” ì‹¤ì œ ë°˜ë³µë¬¸ì´ ë©”ì„œë“œ ë‚´ë¶€ì— ìˆ¨ê²¨ì ¸ìˆê¸° ë•Œë¬¸.

ex) `forEach()`ì˜ ë‚´ë¶€

```java
void forEach(Consumer<? super T> action) {
    Objects.requireNonNull(action); // ë§¤ê°œ ë³€ìˆ˜ actionì— ëŒ€í•œ null ì²´í¬

    for (T t : src) {
        action.accept(t);
    } // ë°˜ë³µë¬¸ì´ ë©”ì„œë“œ ë‚´ë¶€ì— ìˆ¨ì–´ìˆìŒ
}
```

&nbsp;

### ìŠ¤íŠ¸ë¦¼ì˜ ì—°ì‚°

ì—°ì‚°(operation): ìŠ¤íŠ¸ë¦¼ì— ì •ì˜ëœ ë©”ì„œë“œ ì¤‘ì—ì„œ ë°ì´í„° ì†ŒìŠ¤ë¥¼ ë‹¤ë£¨ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒ

- ì¤‘ê°„ ì—°ì‚°

  ì—°ì‚° ê²°ê³¼ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì— ì¤‘ê°„ ì—°ì‚° ì—¬ëŸ¬ ê°œë¥¼ chaining í•  ìˆ˜ ìˆìŒ

- ìµœì¢… ì—°ì‚°

  ì—°ì‚° ê²°ê³¼ê°€ ìŠ¤íŠ¸ë¦¼ì´ ì•„ë‹˜. ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ì†Œëª¨í•˜ë©´ì„œ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ë¯€ë¡œ ë‹¨ í•œë²ˆë§Œ ì—°ì‚° ê°€ëŠ¥

ex)

```java
stream.distinct().limit(5).sorted().forEach(System.out::println);
// distinct ~ sorted ê¹Œì§€ê°€ ì¤‘ê°„ ì—°ì‚° ë©”ì„œë“œë“¤ì´ê³ , forEachê°€ ìµœì¢… ì—°ì‚°ì„ í•˜ëŠ” ë©”ì„œë“œ
```

&nbsp;

ì¤‘ê°„ê³¼ ìµœì¢… ì—°ì‚°ì„ í•˜ëŠ” ì—¬ëŸ¬ ë©”ì„œë“œê°€ ìˆëŠ”ë°, (êµì¬ p.816)

ì¤‘ê°„ ì—°ì‚°ì˜ í•µì‹¬ì€ `map()`ê³¼ `flatMap()`

ìµœì¢… ì—°ì‚°ì˜ í•µì‹¬ì€ `reduce()`ì™€ `collect()`

&nbsp;

### ì§€ì—°ëœ ì—°ì‚°

ìŠ¤íŠ¸ë¦¼ì— ì¤‘ê°„ ì—°ì‚°ì„ í˜¸ì¶œí•´ë„ ì¦‰ê°ì ìœ¼ë¡œ ì—°ì‚°ì´ ìˆ˜í–‰ë˜ì§€ëŠ” ì•Šê³ , ìµœì¢… ì—°ì‚°ì´ í˜¸ì¶œë˜ì–´ì•¼ë§Œ ë¹„ë¡œì†Œ ì¤‘ê°„ ì—°ì‚°ë¶€í„° ìµœì¢… ì—°ì‚°ê¹Œì§€ì˜ ì—°ì‚°ì´ ìˆ˜í–‰ë¨.

&nbsp;

### Stream\<Integer\>ì™€ IntStream

ìš”ì†Œì˜ íƒ€ì…ì´ Tì¸ ìŠ¤íŠ¸ë¦¼ì€ ì œë„¤ë¦­ íƒ€ì…ì´ ë‹¬ë¦° `Stream<T>`ì´ì§€ë§Œ,

ì˜¤í† ë°•ì‹±/ì–¸ë°•ì‹±ìœ¼ë¡œ ì¸í•œ ë¹„íš¨ìœ¨ì„ ì¤„ì´ê¸° ìœ„í•´ ê¸°ë³¸í˜• ë°ì´í„°ë¥¼ ë‹¤ë£¨ëŠ” ìŠ¤íŠ¸ë¦¼ì¸ `IntStream`, `LongStream`, `DoubleStream`ì´ ì œê³µë¨.

> `Stream<Integer>`ë³´ë‹¤ëŠ” `IntStream`ì„ ì‚¬ìš©í•˜ì.

&nbsp;

### ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼

ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë³‘ë ¬ ì²˜ë¦¬í•˜ê³ ì í•  ë•ŒëŠ” ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•¨.

ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì€ ë‚´ë¶€ì ìœ¼ë¡œ fork & join í”„ë ˆì„ì›ì„ ì´ìš©í•´ì„œ ì—°ì‚°ì„ ë³‘ë ¬ì ìœ¼ë¡œ ìˆ˜í–‰í•¨.

&nbsp;

ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“œë ¤ë©´ `parallel()`ì„ í˜¸ì¶œí•˜ë©´ ë¨.

ë³‘ë ¬ë¡œ ì²˜ë¦¬ë˜ì§€ ì•Šê²Œ í•˜ë ¤ë©´ `sequential()`ì„ í˜¸ì¶œ (ê¸°ë³¸ê°’ì´ë¯€ë¡œ ë”°ë¡œ í˜¸ì¶œí•  í•„ìš”ëŠ” ì—†ìŒ)

> `parallel()`ì„ í˜¸ì¶œí•œ ìŠ¤íŠ¸ë¦¼ì„ ë‹¤ì‹œ ë³‘ë ¬ì´ ì•„ë‹ˆê²Œ ë§Œë“¤ê¸° ìœ„í•´ í˜¸ì¶œí•¨

ë©€í‹° ì“°ë ˆë“œê°€ í•­ìƒ ë¹ ë¦„ì„ ë³´ì¥í•˜ëŠ” ê²ƒì€ ì•„ë‹ˆë¯€ë¡œ, ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ë„ ìƒí™©ì— ë”°ë¼ ì ì ˆíˆ ì‚¬ìš©í•´ì•¼í•¨.

&nbsp;

## ìŠ¤íŠ¸ë¦¼ ë§Œë“¤ê¸°

ë°ì´í„° ì†ŒìŠ¤ì˜ ì¢…ë¥˜ë³„ ìŠ¤íŠ¸ë¦¼ ìƒì„± ë°©ë²•

&nbsp;

### ì»¬ë ‰ì…˜

ì»¬ë ‰ì…˜ì˜ ìµœê³  ì¡°ìƒì¸ `Collection`ì— `stream()`ì´ ì •ì˜ë˜ì–´ ìˆìŒ

ex) ì •ìˆ˜ Listë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ê¸°

```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);

Stream<Integer> intStream = list.stream();
// IntStream intStream = (IntStream) list.stream();
```

&nbsp;

### ë°°ì—´

`Stream`ê³¼ `Arrays`ì— ë°°ì—´ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“œëŠ” static ë©”ì„œë“œê°€ ì •ì˜ë˜ì–´ ìˆìŒ

ex) ë¬¸ìì—´ ë°°ì—´ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ê¸°

```java
Stream<String> strStream = Stream.of("a", "b", "c");
Stream<String> strStream = Stream.of(new String[]{"a", "b", "c"});

Stream<String> strStream = Arrays.stream(new String[]{"a", "b", "c"});
Stream<String> strStream = Arrays.stream(new String[]{"a", "b", "c"}, 0, 3);
// 0ì€ startInclusive, 3ì€ endExclusiveë¡œ ì¸ë±ìŠ¤ 0ë¶€í„° 3ê¹Œì§€ì˜ ì›ì†Œë¥¼ í¬í•¨ì‹œì¼œ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“ ë‹¤ëŠ” ì˜ë¯¸.
// ë ë²”ìœ„ëŠ” í¬í•¨ë˜ì§€ ì•Šìœ¼ë¯€ë¡œ 0, 1, 2ë²ˆì§¸ ì›ì†Œê°€ í¬í•¨ë¨
```

&nbsp;

ì•ì„œ ë¶ˆí•„ìš”í•œ ì˜¤í† ë°•ì‹±/ì–¸ë°•ì‹±ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ê¸°ë³¸í˜•ì„ ë‹¤ë£¨ëŠ” ìŠ¤íŠ¸ë¦¼ì´ ìˆë‹¤ê³  í–ˆëŠ”ë°, ì´ë“¤ì„ ìœ„í•œ ìƒì„± ë©”ì„œë“œë„ ë‹¹ì—°íˆ ì¡´ì¬í•¨

ex) ì •ìˆ˜ ë°°ì—´ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¤ê¸°

```java
IntStream intStream = IntStream.of(1, 2, 3);
IntStream intStream = IntStream.of(new int[]{1, 2, 3});

IntStream intStream = Arrays.stream(new int[]{1, 2, 3});
IntStream intStream = Arrays.stream(new int[]{1, 2, 3}, 0, 3);
```

&nbsp;

### íŠ¹ì • ë²”ìœ„ì˜ ì •ìˆ˜

`IntStream`ê³¼ `LongStream`ì—ëŠ” ì§€ì •ëœ ë²”ìœ„ì˜ ì—°ì†ëœ ì •ìˆ˜ë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ìƒì„±í•´ì„œ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œ `range()`ì™€ `rangeClosed()`ê°€ ìˆìŒ

- `range`(int start, int end)

- `rangeClosed`(int begin, int end)

ë‘˜ì˜ ì°¨ì´ëŠ” endì— ë“¤ì–´ê°€ëŠ” ìˆ«ìë¥¼ ë²”ìœ„ì— í¬í•¨í•˜ëŠëƒ ì•ˆí•˜ëŠëƒ. (`rangeClosed()`ëŠ” í¬í•¨í•¨)

&nbsp;

### ì„ì˜ì˜ ìˆ˜

ë‚œìˆ˜ ìƒì„±ì— ì‚¬ìš©ë˜ëŠ” `Random` í´ë˜ìŠ¤ì—ëŠ” íŠ¹ì • íƒ€ì…ì˜ ë‚œìˆ˜ë“¤ë¡œ ì´ë£¨ì–´ì§„ ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜í•˜ëŠ” ë©”ì„œë“œê°€ ìˆìŒ.

- IntStream `ints`()

- LongStream `longs`()

- DoubleStream `doubles`()

ì´ë“¤ì€ í¬ê¸°ê°€ ë¬´í•œëŒ€ì¸ ë¬´í•œ ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜í•˜ë¯€ë¡œ `limit()`ì„ ì‚¬ìš©í•´ì„œ ìŠ¤íŠ¸ë¦¼ì˜ í¬ê¸°ë¥¼ ì œí•œí•´ì£¼ì–´ì•¼í•¨.

```java
IntStream intStream = new Random().ints().limit(5); // ìš”ì†Œ 5ê°œë¥¼ ê°€ì§„ ìœ í•œ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“¦
```

ë˜ëŠ” ì¸ìì— ìŠ¤íŠ¸ë¦¼ì˜ í¬ê¸°ë¥¼ ë„£ì–´ í¬ê¸°ë¥¼ ì œí•œ.

```java
IntStream intStream = new Random().ints(5);
```

&nbsp;

ê¸°ë³¸ì ìœ¼ë¡œ ìœ„ ë‚œìˆ˜ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†ŒëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë²”ìœ„ë¥¼ ê°€ì§.

- `ints()`: Integer.MIN_VALUE ì´ìƒ, Integer.MAX_VALUE ì´í•˜

- `longs()`: Long.MIN_VALUE ì´ìƒ, Long.MAX_VALUE ì´í•˜

- `doubles()`: 0.0 ì´ìƒ, 1.0 ì´í•˜

ì´ ê¸°ë³¸ ë²”ìœ„ê°€ ì•„ë‹Œ ì§€ì •ëœ ë²”ìœ„ì˜ ë‚œìˆ˜ ìŠ¤íŠ¸ë¦¼ì„ ë§Œë“œë ¤ë©´ ì¸ìë¡œ ë²”ìœ„ë¥¼ ëª…ì‹œí•´ì£¼ë©´ ë¨.

- IntStream `ints`(int start, int end)

- LongStream `longs`(long start, long end)

- DoubleStream `doubles`(double start, double end)

ì™„ì „ì²´

- IntStream `ints`(long size, int start, int end)

- LongStream `longs`(long size, long start, long end)

- DoubleStream `doubles`(long size, double start, double end)

&nbsp;

### ëŒë‹¤ì‹ - iterate(), generate()

`Stream` í´ë˜ìŠ¤ì˜ static ë©”ì„œë“œ `iterate()`ì™€ `generate()`ì€ ëŒë‹¤ì‹ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì•„ ì´ ëŒë‹¤ì‹ì— ì˜í•´ ê³„ì‚°ë˜ëŠ” ê°’ë“¤ì„ ìš”ì†Œë¡œ ê°–ëŠ” ë¬´í•œ ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±

- static \<T\> Stream<T> iterate(T seed, UnaryOperator<T> f)

  ì§€ì •ëœ seed ê°’ìœ¼ë¡œ ì‹œì‘í•´ì„œ ëŒë‹¤ì‹ fë¡œ ê³„ì‚°ëœ ê²°ê³¼ë¥¼ seedë¡œ ì§€ì •í•œ ë’¤ ì´ ê³¼ì • ë°˜ë³µ.

  ex)

  ```java
  Stream<Integer> evenNumStream = Stream.iterate(0, n -> n + 2);
  // 0, 2, 4, 6, 8, ...
  ```

- static \<T\> Stream<T> generate(Supplier<T> s)

  ëŒë‹¤ì‹ sì— ì˜í•´ ê³„ì‚°ë˜ëŠ” ê²°ê³¼ë¥¼ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¡œ ë„£ì§€ë§Œ, `iterate()`ê³¼ëŠ” ë‹¬ë¦¬ ì´ì „ ê²°ê³¼ê°’ì„ ì´ìš©í•´ ë‹¤ìŒ ìš”ì†Œì˜ ê°’ì„ ì‚°ì¶œí•˜ì§€ ì•ŠìŒ.

  ex)

  ```java
  Stream<Double> randomStream = Stream.generate(Math::random);
  // 0 ~ 1 ì‚¬ì´ì˜ ëœë¤ doubleê°’ì„ ìš”ì†Œë¡œ í•˜ëŠ” ë¬´í•œ ìŠ¤íŠ¸ë¦¼
  ```

&nbsp;

ğŸ“Œ [ì£¼ì˜] `iterate()`ì™€ `generate()`ë¡œ ìƒì„±ëœ ìŠ¤íŠ¸ë¦¼ì€ ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ íƒ€ì…ì˜ ì°¸ì¡°ë³€ìˆ˜ë¡œ ë‹¤ë£° ìˆ˜ ì—†ìŒ

```java
DoubleStream randomStream = Stream.generate(Math::random); // (X)
```

êµ³ì´ í•˜ë ¤ë©´ mappingì„ ê±°ì³ì•¼í•¨

```java
DoubleStream randomStream = Stream.generate(Math::random).mapToDouble(Double::valueOf); // (O)
```

&nbsp;

### íŒŒì¼

`java.nio.file` íŒ¨í‚¤ì§€ì˜ `File` í´ë˜ìŠ¤ì—ëŠ” íŒŒì¼ì„ ë‹¤ë£¨ëŠ”ë° í•„ìš”í•œ ë©”ì„œë“œê°€ ì¡´ì¬.

- static Stream\<Path\> `list`(Path dir)

  > `Path`: í•˜ë‚˜ì˜ íŒŒì¼ ë˜ëŠ” ê²½ë¡œ

  ì§€ì •ëœ ë””ë ‰í† ë¦¬ì— ìˆëŠ” íŒŒì¼ì˜ ëª©ë¡ì„ ìš”ì†Œë¡œ ê°–ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•´ì„œ ë°˜í™˜

- static Stream\<String\> `lines`(Path path)

  íŒŒì¼ì˜ í•œ í–‰(line)ì„ ìš”ì†Œë¡œ ê°–ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ìƒì„±í•´ì„œ ë°˜í™˜

&nbsp;

### ë¹ˆ ìŠ¤íŠ¸ë¦¼

ìŠ¤íŠ¸ë¦¼ì— ì—°ì‚°ì„ ìˆ˜í–‰í•œ ê²°ê³¼, ìš”ì†Œê°€ í•˜ë‚˜ë„ ì—†ì„ ë•Œ, `null`ë³´ë‹¤ëŠ” ë¹ˆ ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜í•˜ëŠ”ê²Œ ë‚˜ìŒ.

`Stream`ì˜ static ë©”ì„œë“œì¸ `empty()`ë¥¼ ì‚¬ìš©í•´ì„œ ìƒì„±í•  ìˆ˜ë„ ìˆìŒ.

```java
Stream emptyStream = Stream.empty(); // ë¹ˆ ìŠ¤íŠ¸ë¦¼ ìƒì„±
```

&nbsp;

### ë‘ ìŠ¤íŠ¸ë¦¼ì˜ ì—°ê²°

`Stream`ì˜ static ë©”ì„œë“œ `concat()`ì„ ì´ìš©í•´ ë‘ ìŠ¤íŠ¸ë¦¼ì„ ì—°ê²°ì‹œí‚¬ ìˆ˜ ìˆìŒ

ë‹¨, ë‘ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ íƒ€ì…ì´ ê°™ì•„ì•¼í•¨.

```java
String[] strArr1 = {"aaa", "bbb", "ccc"};
String[] strArr2 = {"ddd", "eee", "fff"};

Stream<String> strStream1 = Stream.of(strArr1);
Stream<String> strStream2 = Stream.of(strArr2);

Stream<String> strStream3 = Stream.concat(strStream1, strStream2);
```

&nbsp;

## ìŠ¤íŠ¸ë¦¼ì˜ ì¤‘ê°„ì—°ì‚°

### ìŠ¤íŠ¸ë¦¼ ìë¥´ê¸° - skip(), limit()

- Stream<T> `skip`(long n)

  ìŠ¤íŠ¸ë¦¼ì˜ ì²« nê°œ ìš”ì†Œë¥¼ ê±´ë„ˆë›´ ìŠ¤íŠ¸ë¦¼ì„ ë°˜í™˜

- Stream<T> `limit`(long size)

  ìŠ¤íŠ¸ë¦¼ì˜ ì²« ìš”ì†Œë¶€í„° ì‹œì‘í•´ì„œ size ê°œìˆ˜ë§Œí¼ì˜ ìš”ì†Œë¥¼ í¬í•¨ì‹œí‚¤ê³  ê·¸ ë°–ì˜ ìš”ì†ŒëŠ” ì˜ë¼ëƒ„

&nbsp;

### ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ê±¸ëŸ¬ë‚´ê¸° - filter(), distinct()

- Stream<T> `distinct`()

  ìŠ¤íŠ¸ë¦¼ì—ì„œ ì¤‘ë³µëœ ìš”ì†Œë¥¼ ì œê±°í•œ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜

- Stream<T> `filter`(Predicate<? super T> p)

  pì˜ í•„í„°ë§ ì¡°ê±´ì— ë¶€í•©í•˜ëŠ” ìš”ì†Œë“¤ë§Œì„ í¬í•¨í•œ ìŠ¤íŠ¸ë¦¼ ë°˜í™˜

  > ë°˜í™˜ íƒ€ì…ì´ `boolean`ì¸ ëŒë‹¤ì‹ì„ ë§¤ê°œë³€ìˆ˜ë¡œ ë„˜ê¸¸ ìˆ˜ ìˆìŒ

&nbsp;

### ì •ë ¬ - sorted()

- Stream<T> `sorted`()

  ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œê°€ ê°€ì§„ ê¸°ë³¸ ì •ë ¬ ê¸°ì¤€ì— ë”°ë¼ ì •ë ¬

  > ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œê°€ `Comparable`ì„ êµ¬í˜„í•œ í´ë˜ìŠ¤ íƒ€ì…ì´ ì•„ë‹ˆë©´ ì˜ˆì™¸ ë°œìƒ

- Stream<T> `sorted`(Comparator<? super T> c)

  ì§€ì •ëœ Comparatorë¥¼ ê°€ì§€ê³  ìŠ¤íŠ¸ë¦¼ì„ ì •ë ¬.

  Comparator ëŒ€ì‹  `int`í˜•ì„ ë°˜í™˜í•˜ëŠ” ëŒë‹¤ì‹ì„ ì‚¬ìš©í•´ë„ ë¨

&nbsp;

`JDK` 1.8ë¶€í„° `Comparator` ì¸í„°í˜ì´ìŠ¤ì— ìœ ìš©í•œ static ë©”ì„œë“œì™€ default ë©”ì„œë“œë“¤ì´ ì¶”ê°€ë˜ë©´ì„œ ë³´ë‹¤ ì‰½ê²Œ ì •ë ¬ì„ í•  ìˆ˜ ìˆìŒ.

ì´ ë©”ì„œë“œë“¤ì€ ëª¨ë‘ `Comparator<T>`ë¥¼ ë°˜í™˜í•˜ë¯€ë¡œ, `sorted()`ì˜ ë§¤ê°œë³€ìˆ˜ë¡œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆê³ , chainingë„ ê°€ëŠ¥í•¨.

&nbsp;

ê°€ì¥ ê¸°ë³¸ì ì¸ ë©”ì„œë“œëŠ” `comparing()`

- `comparing`(Function\<T, U> keyExtractor)

  ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œê°€ `Comparable`ì„ êµ¬í˜„í•œ í´ë˜ìŠ¤ íƒ€ì…ì¸ ê²½ìš° ì‚¬ìš©

- `comparing`(Function\<T, U> keyExtractor, Comparator\<U> keyComparator)

  ê·¸ ì™¸ì˜ ê²½ìš°ì—ëŠ” ì§ì ‘ `Comparator`ë¥¼ ì§€ì •í•´ì¤˜ì•¼í•¨

> `keyExtractor` í•¨ìˆ˜ëŠ” ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ íƒ€ì…(í´ë˜ìŠ¤) ì•ˆì—ì„œ ë¹„êµ ê¸°ì¤€ì´ ë  ì†ì„±ì„ ì§€ì •í•˜ëŠ” í•¨ìˆ˜
>
> `keyComparator`ëŠ” `keyExtractor` í•¨ìˆ˜ê°€ ì§€ì •í•´ì¤€ key(ë¹„êµ ê¸°ì¤€)ì„ ê°€ì§€ê³  ì‹¤ì œ ë¹„êµ ì‘ì—…ì„ ìˆ˜í–‰í•¨.

&nbsp;

ë¹„êµ ëŒ€ìƒì´ ê¸°ë³¸í˜•ì¸ ê²½ìš°ì—ëŠ” ì•„ë˜ ë©”ì„œë“œ ì‚¬ìš© (ë¶ˆí•„ìš”í•œ ì˜¤í† ë°•ì‹±/ì–¸ë°•ì‹±ì„ í•˜ì§€ ì•Šê¸° ìœ„í•¨)

- `comparingInt`(ToIntFunction\<T> keyExtractor)

- `comparingLong`(ToLongFunction\<T> keyExtractor)

- `comparingDouble`(ToDoubleFunction\<T> keyExtractor)

&nbsp;

ì •ë ¬ ì¡°ê±´ì„ ì¶”ê°€í•  ë•ŒëŠ” `thenComparing()` ì‚¬ìš©

- `thenComparing`(Comparator\<T> other)

- `thenComparing`(Function\<T, U> keyExtractor)

- `thenComparing`(Function\<T, U> keyExtractor, Comparator\<U> keyComparator)

&nbsp;

```java
class StreamExample {
    public static void main(String[] args) {
        Stream<Student> studentStream = Stream.of(
                new Student("Andy", 3, 240),
                new Student("Charles", 1, 300),
                new Student("James", 2, 180),
                new Student("David", 1, 200),
                new Student("Kevin", 2, 220),
                new Student("Harry", 3, 280),
                new Student("Peter", 2, 120)
            );

        studentStream.sorted(Comparator.comparing(Student::getClassNum) // ë°˜ ë„˜ë²„ë¥¼ ê°€ì§€ê³  ì •ë ¬ (ì˜¤ë¦„ì°¨ìˆœ)
            .thenComparing(Comparator.naturalOrder())) // ê¸°ë³¸ ë¹„êµ ê¸°ì¤€(ì ìˆ˜)ì„ ê°€ì§€ê³  ì •ë ¬ (ë‚´ë¦¼ì°¨ìˆœ)
            .forEach(System.out::println);
    }
}

class Student implements Comparable<Student> {
    String name;
    int classNum;
    int totalScore;

    Student(String name, int classNum, int totalScore) {
        this.name = name;
        this.classNum = classNum;
        this.totalScore = totalScore;
    }

    public String toString() {
        return String.format("%s(%dë°˜, %dì )", name, classNum, totalScore);
    }

    String getName() { return name; }
    int getClassNum() { return classNum; }
    int getTotalScore() { return totalScore; }

    @Override
    public int compareTo(Student s) {
        return s.totalScore - this.totalScore; // Student ê°„ì˜ ê¸°ë³¸ ë¹„êµ ê¸°ì¤€ì€ ì ìˆ˜ (ë‚´ë¦¼ ì°¨ìˆœ)
    }
}
```

ì‹¤í–‰ ê²°ê³¼)

    Charles(1ë°˜, 300ì )
    David(1ë°˜, 200ì )
    Kevin(2ë°˜, 220ì )
    James(2ë°˜, 180ì )
    Peter(2ë°˜, 120ì )
    Harry(3ë°˜, 280ì )
    Andy(3ë°˜, 240ì )

&nbsp;

`sorted()`ì•ˆì—ì„œ `comparing()`, `thenComparing()`ì´ chaining ë¨. ë©”ì„œë“œ ëª¨ë‘ `Comparator<T>`ë¥¼ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì— ê°€ëŠ¥.

&nbsp;

## ë³€í™˜ - map()

ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ê°€ìš´ë° ì›í•˜ëŠ” í•„ë“œë§Œ ë½‘ì•„ë‚´ê±°ë‚˜, ìŠ¤íŠ¸ë¦¼ì„ íŠ¹ì • í˜•íƒœë¡œ ë³€í™˜í•´ì•¼ í•  ë•Œ ì‚¬ìš©.

```java
Stream<R> map(Function<? super T, ? extends R> mapper)
```

Tíƒ€ì…ì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì•„ Ríƒ€ì…ì˜ ë°˜í™˜ê°’ì„ ë‚´ë³´ë‚´ëŠ” í•¨ìˆ˜ `mapper`ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŒ.

ê·¸ë¦¬ê³ ì„  Ríƒ€ì…ì˜ ìŠ¤íŠ¸ë¦¼ì¸ `Stream<R>`ë¥¼ ë°˜í™˜

> ì¦‰, ê¸°ì¡´ `Stream<T>`ë¥¼ `Stream<R>`ë¡œ ë³€í™˜ì‹œì¼°ë‹¤ê³  ë³¼ ìˆ˜ ìˆìŒ

ex) Fileë¡œ ì´ë£¨ì–´ì§„ ìŠ¤íŠ¸ë¦¼ì—ì„œ íŒŒì¼ ì´ë¦„ë§Œ ì¶”ì¶œí•´ì„œ ìŠ¤íŠ¸ë¦¼ì— ë‹´ê¸°

```java
Stream<File> fileStream = Stream.of(
        new File("Ex1.java"),
        new File("Hello"),
        new File("Memo.txt"),
        new File("README.md")
);

Stream<String> fileNameStream = fileStream.map(File::getName);
fileNameStream.forEach(System.out::println);
```

&nbsp;

ì¤‘ê°„ ì—°ì‚°ì˜ ì¼ì¢…ì´ë¯€ë¡œ ìŠ¤íŠ¸ë¦¼ì— ì—¬ëŸ¬ë²ˆ `map()`ì„ ì ìš©í•  ìˆ˜ ìˆìŒ

&nbsp;

### ì¡°íšŒ - peek()

ì—¬ëŸ¬ ê°œì˜ ì—°ì‚°ì´ chaining ë˜ì–´ ìˆì„ ë•Œ, `peek()`ì„ í†µí•´ ì¤‘ê°„ì— íŠ¹ì • ì—°ì‚°ì´ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬ë˜ì—ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŒ.

```java
fileStream.map(File::getName)
        .filter(s -> s.indexOf('.') != -1) // í™•ì¥ì ì—†ëŠ” íŒŒì¼ì€ ê±¸ëŸ¬ëƒ„
        .peek(s -> System.out.printf("File Name: %s%n", s)) // íŒŒì¼ëª… ì¶œë ¥
        .map(s -> s.substring(s.indexOf('.') + 1)) // í™•ì¥ìëª…ë§Œ ì¶”ì¶œí•¨
        .peek(s -> System.out.printf("File Extension: %s%n", s)) // í™•ì¥ìëª… ì¶œë ¥
        .forEach(System.out::println); // í˜„ì¬ ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œ ì¶œë ¥
```

ì‹¤í–‰ ê²°ê³¼)

    File Name: Ex1.java
    File Extension: java
    java
    File Name: Memo.txt
    File Extension: txt
    txt
    File Name: README.md
    File Extension: md
    md

ë³´ë‹¤ì‹œí”¼ `peek()`ìœ¼ë¡œ `filter()`ì™€ `map()`ì˜ ì—°ì‚°ì´ ì˜¬ë°”ë¥´ê²Œ ë˜ì—ˆëŠ”ì§€ ì¤‘ê°„ì— í™•ì¸ì„ í•  ìˆ˜ ìˆìŒ.

&nbsp;

### mapToInt(), mapToLong(), mapToDouble()

`map()`ì€ ì—°ì‚° ê²°ê³¼ë¡œ `Stream<T>`ë¥¼ ë°˜í™˜í•˜ëŠ”ë°, ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ íƒ€ì…ì´ ìˆ«ìì¸ ê²½ìš°ì—” ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì´ ë” íš¨ìœ¨ì ì„.

mapping ê²°ê³¼ë¡œ ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ `IntStream`, `LongStream`, `DoubleStream`ì„ ë°˜í™˜í•´ì£¼ëŠ” ê²ƒì´ `mapToInt()`, `mapToLong()`, `mapToDouble()`

&nbsp;

`Stream<T>`ì™€ ë‹¬ë¦¬, ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ì€ ìˆ«ìë¥¼ ë‹¤ë£¨ëŠ”ë° í¸ë¦¬í•œ ë©”ì„œë“œë¥¼ ì œê³µí•¨

- int `sum`(): ìŠ¤íŠ¸ë¦¼ ìš”ì†Œ ì´í•©

- OptionalDouble `average`(): í‰ê· (ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ì´í•© ë‚˜ëˆ„ê¸° ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ ê°œìˆ˜) ë°˜í™˜

- OptionalInt `max`(): ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ì¤‘ ìµœëŒ€ê°’ ë°˜í™˜

- OptionalInt `min`(): ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ ì¤‘ ìµœì†Œê°’ ë°˜í™˜

> `OptionalInt`, `OptionalDouble`ì€ ê°ê° ë‚´ë¶€ì ìœ¼ë¡œ `int`, `Double` íƒ€ì…ì„ ê°€ì§€ê³  ìˆëŠ” ì¼ì¢…ì˜ Wrapper í´ë˜ìŠ¤
>
> ìŠ¤íŠ¸ë¦¼ì— ìš”ì†Œê°€ ì•„ë¬´ ê²ƒë„ ì—†ëŠ” ìƒí™©ì¼ ë•Œ, sumì€ ë‹¹ì—°íˆ 0ì´ë¯€ë¡œ ë¬¸ì œë  ê²ƒì´ ì—†ì§€ë§Œ max ê°™ì€ ê°’ì€ ì•„ì˜ˆ ì¡´ì¬í•  ìˆ˜ê°€ ì—†ìœ¼ë¯€ë¡œ í•¨ë¶€ë¡œ 0ì„ ë°˜í™˜í•˜ë©´ ì•ˆë¨.
>
> ì´ëŸ° ìƒí™©ì—ì„œ `OptionalInt`ë¥¼ ì‚¬ìš©í•˜ë©´ ë³„ë„ì˜ null-checking ì—†ì´ `OptionalInt`ì˜ ë‚´ë¶€ ë©”ì„œë“œë¡œ ì•…ëª… ë†’ì€ `NullPointerException`ì„ íšŒí”¼í•  ìˆ˜ ìˆê²Œë¨.
>
> ì˜ˆë¥¼ ë“¤ì–´ `OptionalInt`ì˜ `getAsInt()`ì„ í˜¸ì¶œí–ˆì„ ë•Œ ë‚´ë¶€ `int`ê°’ì´ ì¡´ì¬í•˜ë©´ ê·¸ ê°’ì„ ë°˜í™˜í•˜ê³ , ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ `NoSuchElementException`ì„ ë˜ì§.

&nbsp;

ì´ ë©”ì„œë“œë“¤ì€ ìµœì¢… ì—°ì‚°ì´ë¯€ë¡œ ì—°ì‚° í›„ì— ìŠ¤íŠ¸ë¦¼ì´ ë‹«í˜. (ë°˜ë³µí•´ì„œ í˜¸ì¶œ ë¶ˆê°€ëŠ¥)

í•œë²ˆ ì“°ë©´ ìŠ¤íŠ¸ë¦¼ì´ ë‹«í˜€ë²„ë¦¬ëŠ” ë¶ˆí¸í•¨ ë•Œë¬¸ì— `summarStatistics()`ë¼ëŠ” ë©”ì„œë“œê°€ ë”°ë¡œ ì œê³µë¨

```java
IntSummaryStatistics stat = scoreStream.summaryStatistics();

long totalCount = stat.getCount();
long totalScore = stat.getSum();
double avgScore = stat.getAverage();
int minScore = stat.getMin();
int maxScore = stat.getMax();
```

í•˜ë‚˜ì˜ `IntSummaryStatistics`ë¥¼ ìƒì„±í•´ ì—¬ëŸ¬ê°€ì§€ ê°€ê³µ ë°ì´í„°ë¥¼ ì–»ì„ ìˆ˜ ìˆìŒ.

&nbsp;

ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ì„ ì œë„¤ë¦­ íƒ€ì…ì´ ìˆëŠ” ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜

- Stream\<U> `mapToObj`(IntFunction<? extends U> mapper)

  ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ &#8594; `Stream<T>`

  ```java
  IntStream randomStream = new Random().ints(1, 10);
  Stream<String> stringStream = randomStream.mapToObj(i -> i + "")
  ```

- Stream\<Integer> `boxed`()

  ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ &#8594; `Stream<Integer>`

  ```java
  IntStream randomStream = new Random().ints(1, 10);
  Stream<Integer> integerStream = randomStream.boxed();
  ```

  > ê¸°ì¡´ ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œë¥¼ `Integer`íƒ€ì…ìœ¼ë¡œ boxing í•´ì¤Œ

&nbsp;

### flatMap() - Stream\<T[]>ë¥¼ Stream\<T>ë¡œ ë³€í™˜

ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œê°€ ë°°ì—´ íƒ€ì…ì´ê±°ë‚˜, `map()`ìœ¼ë¡œ ì—°ì‚°í•˜ê³ ë‚œ ë’¤ ìš”ì†Œê°€ ë°°ì—´ íƒ€ì…ì¼ ë•Œ, ì¦‰ `Stream<T[]>`ì¼ ë•Œ, í•´ë‹¹ ìŠ¤íŠ¸ë¦¼ì„ `Stream<T>`ë¡œ ë§Œë“¤ê³  ì‹¶ë‹¤ë©´ `flatMap()` ì‚¬ìš©

&nbsp;

ë¬¸ìì—´ ë°°ì—´ë¡œ ì´ë£¨ì–´ì§„ ìŠ¤íŠ¸ë¦¼ì´ ìˆìŒ.

```java
Stream<String[]> strArrStream = Stream.of(new String[]{"aaa", "bbb", "ccc"}, new String[]{"ddd", "eee", "fff"});
```

`map()`ì„ í†µí•´ ë°°ì—´ì„ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë§Œë“œëŠ” `Arrays.stream()` ë©”ì„œë“œ í˜¸ì¶œ

```java
Stream<Stream<String>> strStreamStream = strArrStream.map(Arrays::stream);
```

`Stream<String>`ì„ ì›í–ˆëŠ”ë°, `Stream<Stream<String>>`ì´ ë‚˜ì™€ë²„ë¦¼

ì´ ë•Œ `map()` ëŒ€ì‹  `flatMap()`ì„ ì‚¬ìš©í•˜ë©´ ì˜ë„í•œ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŒ

```java
Stream<String> strStream = strArrStream.flatMap(Arrays::stream);
```

&nbsp;

## Optional\<T>ì™€ OptionalInt

`Optional<T>`ëŠ” ì œë„¤ë¦­ í´ë˜ìŠ¤ë¡œ, `T`íƒ€ì…ì˜ ê°ì²´ë¥¼ ê°ì‹¸ëŠ” Wrapper í´ë˜ìŠ¤.

ìµœì¢… ì—°ì‚°ì˜ ê²°ê³¼ë¡œ `Optional<T>`ë¥¼ ë°˜í™˜í•˜ë©´, ë°˜í™˜ë˜ëŠ” ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ìƒí™©(`null`ì¼ ë•Œ)ì„ ëŒ€ë¹„í•´ ë²ˆê±°ë¡­ê²Œ null-checkingì„ ë”°ë¡œ í•˜ì§€ ì•Šì•„ë„ ë¨.

> `null` ëŒ€ì‹  ë¹„ì–´ìˆëŠ” `Optional` ê°ì²´ê°€ ë°˜í™˜ë¨

&nbsp;

### Optional ê°ì²´ ìƒì„±í•˜ê¸°

- `of()`

  ë§¤ê°œë³€ìˆ˜ì— ë„˜ê¸¸ ê°’ì´ `null`ì¼ ê°€ëŠ¥ì„±ì´ ì—†ì„ ë•Œ ì‚¬ìš©

  ```java
  String name = "Andy";
  Optional<String> optVal = Optional.of(name);
  // Optional<String> optVal = Optional.of("Andy");
  // Optional<String> optVal = Optional.of(new String("Andy"));
  ```

- `ofNullable()`

  ë§¤ê°œë³€ìˆ˜ì— ë„˜ê¸¸ ê°’ì´ `null`ì¼ ê°€ëŠ¥ì„±ì´ ìˆì„ ë•Œ ì‚¬ìš©

  > `of()`ë¥¼ ì¼ëŠ”ë° ë§¤ê°œë³€ìˆ˜ ê°’ì´ `null`ì´ë©´ `NullPointerException` ë°œìƒ

  ```java
  Optional<String> optVal = Optional.of(null); // NPE ë°œìƒ
  Optional<String> optVal = Optional.ofNullable(null); // OK
  ```

&nbsp;

`Optional<T>` íƒ€ì…ì˜ ì°¸ì¡°ë³€ìˆ˜ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”í•  ë•ŒëŠ” `empty()`ë¥¼ í˜¸ì¶œ

> `null`ë¡œ ì´ˆê¸°í™”í•  ìˆ˜ë„ ìˆì§€ë§Œ, ì´ëŠ” `Optional`ì˜ ë„ì… ì˜ë„ì™€ëŠ” ë§ì§€ ì•ŠìŒ.
>
> ```java
> Optional<String> optVal = null;
> System.out.println(optVal); // null
> ```
>
> `empty()`ë¡œ ì´ˆê¸°í™”í•˜ëŠ” ë°©ë²•ì´ ê¶Œì¥ë¨ (ë¹ˆ `Optional` ê°ì²´ë¡œ ì´ˆê¸°í™”ë¨)
>
> ```java
> Optional<String> optVal = Optional.empty();
> System.out.println(optVal); // Optional.empty
> ```

```java
Optional<String> optVal = Optional.empty();
```

&nbsp;

### Optional ê°ì²´ì˜ ê°’ ê°€ì ¸ì˜¤ê¸°

`get()`ì„ ì‚¬ìš©í•´ì„œ `Optional` ê°ì²´ì— ì €ì¥ëœ ê°’ì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ.

ë§Œì•½ ê°’ì´ `null`ì´ë©´ `NoSuchElementException` ë°œìƒ

> ì´ë¥¼ ëŒ€ë¹„í•˜ì—¬ `orElse()`ë¥¼ í˜¸ì¶œí•´ ê°’ì´ ì—†ëŠ” ê²½ìš° ì–´ë–¤ ê°’ì„ ëŒ€ì‹  ë°˜í™˜í•  ê²ƒì¸ì§€ ì§€ì •í•  ìˆ˜ ìˆìŒ

```java
Optional<String> optVal = Optional.ofNullable("hello");
String str1 = optVal.get();
System.out.println(str1); // hello

optVal = Optional.empty();
String str2 = optVal.orElse("oops");
System.out.println(str2); // oops
```

&nbsp;

- T `orElseGet`(Supplier<? extends T> supplier)

  ëŒ€ì²´í•  ê°’ì„ ë°˜í™˜í•˜ëŠ” ëŒë‹¤ì‹ì„ ì§€ì •í•  ìˆ˜ ìˆìŒ

  ```java
  String str3 = optVal.orElseGet(String::new);
  // () -> new String()
  ```

- <X extends Throwable> T `orElseThrow`(Supplier<? extends X> exceptionSupplier) throws X

  ì €ì¥ëœ ê°’ì´ `null`ì¼ ë•Œ íŠ¹ì • ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ëŒë‹¤ì‹ì„ ì§€ì •í•  ìˆ˜ ìˆìŒ

  ```java
  String str4 = optVal.orElseThrow(NullPointerException::new);
  // () -> new NullPointerException()
  ```

&nbsp;

`Stream`ì²˜ëŸ¼ `Optional`ì— ëŒ€í•´ì„œë„ `filter()`, `map()`, `flatMap()` ì‚¬ìš© ê°€ëŠ¥

> í•´ë‹¹ ë©”ì„œë“œë“¤ì„ í˜¸ì¶œí•  ë•Œ `Optional`ì˜ ê°’ì´ `null`ì´ë©´ ì•„ë¬´ ì¼ë„ ì•ˆ ì¼ì–´ë‚¨

```java
int result = Optional.of("123")
        .filter(x -> x.length() > 0)
        .map(Integer::parseInt)
        .orElse(-1);

System.out.println(result); // 123
```

&nbsp;

ì•„ë˜ì˜ ë©”ì„œë“œë¥¼ í†µí•´ì„œ `null` ì²˜ë¦¬ ì¡°ê±´ì‹ì„ ê°„ê²°í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ

- boolean `isPresent`()

  `Optional` ê°ì²´ì˜ ê°’ì´ ì¡´ì¬í•˜ë©´ `true`ë¥¼, ê°’ì´ `null`ì´ë©´ `false`ë¥¼ ë°˜í™˜

- void `ifPresent`(Consumer<? super T> action)

  `Optional` ê°ì²´ì˜ ê°’ì´ ì¡´ì¬í•˜ë©´ ëŒë‹¤ì‹ actionì„ ìˆ˜í–‰í•˜ê³ , ê°’ì´ `null`ì´ë©´ ì•„ë¬´ ì¼ë„ ì•ˆí•¨

&nbsp;

```java
if (str != null) {
  System.out.println(str);
}
```

&#8595;

```java
if (Optional.ofNullable(str).isPresent()) {
  System.out.println(str);
}
```

&#8595;

```java
Optional.ofNullable(str).ifPresent(System.out::println);
```

> ê¸°ì¡´ì˜ ì¡°ê±´ë¬¸ì„ `Optional`ê³¼ ê·¸ ë©”ì„œë“œë¥¼ í™œìš©í•´ í•œì¤„ë¡œ ë§Œë“¤ì—ˆìŒ

`ifPresent()`ëŠ” ì£¼ë¡œ `Optional<T>`ë¥¼ ë°˜í™˜í•˜ëŠ” ìµœì¢… ì—°ì‚°ê³¼ ì—°ê³„í•˜ì—¬ ì‚¬ìš©í•¨

&nbsp;

### OptionalInt, OptionalLong, OptionalDouble

ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ì˜ ë©”ì„œë“œë“¤ì€ `OptionalInt`, `OptionalLong`, `OptionalDouble`ì²˜ëŸ¼ ê¸°ë³¸í˜• ê°’ì„ ê°€ì§€ëŠ” `Optional`ì„ ë°˜í™˜í•¨.

ê¸°ë³¸í˜• `Optional`ë“¤ë¡œë¶€í„° ê°’ì„ ì–»ì„ ë•ŒëŠ” `get()` ëŒ€ì‹ , `getAsInt()`, `getAsLong()`, `getAsDouble()`ì„ ì‚¬ìš©í•¨.

&nbsp;

`int`ì˜ ê¸°ë³¸ê°’ì€ 0ì´ë‹ˆê¹Œ

```java
OptionalInt opt = OptionalInt.of(0);
OptionalInt opt2 = OptionalInt.empty();
```

`opt`ì™€ `opt2`ëŠ” ê°™ì€ ê²ƒì¼ê¹Œ?

```java
System.out.println(opt.equals(opt2)); // false
```

ê²°ë¡ ë¶€í„° ë§í•˜ìë©´, ë‹¹ì—°íˆ ë‘˜ì€ ë‹¤ë¦„.

`isPresent()`ê³¼ `getAsInt()`ë¥¼ í†µí•´ì„œë„ êµ¬ë¶„ì´ ê°€ëŠ¥í•œë°, `opt`ì˜ ë©¤ë²„ì¸ `value`ëŠ” 0ì´ê³  `isPresent`ëŠ” `true`ì„. `opt2`ë„ `value`ëŠ” 0ì´ì§€ë§Œ `isPresent`ëŠ” `false`.

```java
System.out.println(opt.isPresent()); // true
System.out.println(opt2.isPresent()); // false

System.out.println(opt.getAsInt()); // 0
System.out.println(opt2.getAsInt()); // NoSuchElementException ë°œìƒ
```

&nbsp;

ê·¸ëŸ°ë° `Optional<T>`ì˜ ê²½ìš°ëŠ” `value`ì— `null`ì„ ì €ì¥í•˜ë©´ `empty()`ë¡œ ì´ˆê¸°í™”í•œ ê²ƒê³¼ ë™ì¼í•œ ê²ƒìœ¼ë¡œ ì·¨ê¸‰í•¨

```java
Optional<String> opt = Optional.ofNullable(null);
Optional<String> opt2 = Optional.empty();

System.out.println(opt.equals(opt2)); // true
```

&nbsp;

## ìŠ¤íŠ¸ë¦¼ì˜ ìµœì¢… ì—°ì‚°

ìµœì¢… ì—°ì‚°ì€ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ì†Œëª¨í•´ê°€ë©° ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ëƒ„.

ê·¸ë˜ì„œ ì—°ì‚°ì´ ëë‚˜ê³  ë‚˜ë©´ ìŠ¤íŠ¸ë¦¼ì´ ë‹«í˜€ ë” ì´ìƒ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ.

&nbsp;

### forEach()

- void `forEach`(Consumer<? super T> action)

  ìŠ¤íŠ¸ë¦¼ì˜ ê° ìš”ì†Œì— ëŒ€í•´ action ì‘ì—…ì„ ìˆ˜í–‰í•¨. ì£¼ë¡œ ëª¨ë“  ìš”ì†Œ ì¶œë ¥ì— ì‚¬ìš©

&nbsp;

### ì¡°ê±´ ê²€ì‚¬ - allMatch(), anyMatch(), noneMatch(), findFirst(), findAny()

`~Match()` ë©”ì„œë“œëŠ” ë§¤ê°œë³€ìˆ˜ë¡œ `Predicate`ì„ ë°›ì•„ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œì— ëŒ€í•´ ê²€ì‚¬ë¥¼ ê±°ì¹œ í›„, `boolean` ê°’ì„ ë°˜í™˜í•¨

```java
boolean result = Stream.of("aaa", "bbbb", "ccccc").anyMatch(s -> s.length() > 4); // true
```

&nbsp;

`find~()` ë©”ì„œë“œëŠ” ì£¼ë¡œ `filter()`ì™€ ì—°ê³„í•´ì„œ ì¡°ê±´ì— ë¶€í•©í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ë‹´ì€ `Optional` ê°ì²´ë¥¼ ë°˜í™˜ (ë¶€í•©í•˜ëŠ” ìš”ì†Œê°€ ì—†ìœ¼ë©´ ë¹ˆ `Optional` ê°ì²´ ë°˜í™˜)

> ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì¸ ê²½ìš°ì—ëŠ” `findAny()` ì‚¬ìš©

```java
Optional<Integer> i = Stream.of(1, 2, 3, 4, 5).filter(n -> n % 2 == 0).findFirst();
i.ifPresent(System.out::println); // 2
```

&nbsp;

### í†µê³„ - count(), max(), min()

ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ì´ ì•„ë‹Œ `Stream<T>`ëŠ” ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì— ëŒ€í•œ í†µê³„ë¥¼ ì–»ì„ ìˆ˜ ìˆëŠ” ë©”ì„œë“œë¡œ ìœ„ 3ê°œê°€ ì „ë¶€

ëŒ€ë¶€ë¶„ ì´ ë©”ì„œë“œë“¤ì„ ì‚¬ìš©í•˜ê¸°ë³´ë‹¤ëŠ” ê¸°ë³¸í˜• ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜í•˜ê±°ë‚˜ `reduce()` ë˜ëŠ” `collect()`ë¥¼ ì‚¬ìš©

&nbsp;

### ë¦¬ë“€ì‹± - reduce()

- Optional\<T> `reduce`(BinaryOperator\<T> accumulator)

  ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì€ `BinaryOperator<T>`ëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ì²˜ìŒ ë‘ ìš”ì†Œë¡œ ì—°ì‚°ì„ ì‹œì‘í•˜ê³ , ì—°ì‚° ê²°ê³¼ë¥¼ ê°€ì§€ê³  ë‹¤ìŒ ìš”ì†Œì™€ ì—°ì‚°ì„ í•¨.

  ì´ ê³¼ì •ì—ì„œ í•˜ë‚˜ì”© ìš”ì†Œë¥¼ ì†Œëª¨í•˜ê³ , ëª¨ë‘ ì†Œëª¨ë˜ë©´ ìµœì¢… ì—°ì‚° ê²°ê³¼ë¥¼ ë°˜í™˜í•¨.

- T `reduce`(T identity, BinaryOperator\<T> accumulator)

  ì›ë¦¬ëŠ” ê°™ì€ë° ë‹¤ë§Œ ì²« ì—°ì‚°ì˜ í”¼ì—°ì‚°ìê°€ ì´ˆê¸°ê°’ `identity`ì™€ ìŠ¤íŠ¸ë¦¼ì˜ ì²«ë²ˆì§¸ ìš”ì†Œë¼ëŠ” ê²ƒì´ ë‹¤ë¦„.

  ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œê°€ 0ê°œë©´ ì´ˆê¸°ê°’ì„ ë°˜í™˜í•˜ë¯€ë¡œ ë°˜í™˜íƒ€ì…ì´ `T`

- U `reduce`(U identity, BiFunction\<U, T, U> accumulator, BinaryOperator\<U> combiner)

  ë§ˆì§€ë§‰ ë§¤ê°œë³€ìˆ˜ì¸ `combiner`ëŠ” ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì— ì˜í•´ ì²˜ë¦¬ëœ ê²°ê³¼ë¥¼ í•©ì¹  ë•Œ ì‚¬ìš©.

&nbsp;

ìµœì¢… ì—°ì‚° `count()`, `max()`, `min()`, `sum()` ë“±ì€ ëª¨ë‘ ë‚´ë¶€ì ìœ¼ë¡œ `reduce()`ë¥¼ ì´ìš©í•´ì„œ êµ¬í˜„ëœ ê²ƒì„.

```java
Stream<Integer> stream = Stream.of(1, 2, 3);

int count = stream.reduce(0, (a, b) -> a + 1);
int max = stream.reduce(Integer.MIN_VALUE, (a, b) -> a > b ? a : b);
int min = stream.reduce(Integer.MAX_VALUE, (a, b) -> a < b ? a : b);
int sum = stream.reduce(0, (a, b) -> a + b);
```

`max()`ì™€ `min()`ì—ëŠ” ì´ˆê¸°ê°’ì´ í•„ìš” ì—†ê¸° ë•Œë¬¸ì— ì•„ë˜ì²˜ëŸ¼ ë” ê°„ê²°í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆìŒ

```java
IntStream stream = IntStream.of(1, 2, 3);

OptionalInt max = stream.reduce(Integer::max);
OptionalInt min = stream.reduce(Integer::min);
// ëŒë‹¤ì‹ë„ ë©”ì„œë“œ ì°¸ì¡°ë¡œ ë°”ê¿¨ìŒ

int maxVal = max.getAsInt();
int minVal = min.getAsInt();
// Optionalì—ì„œ ê°’ì„ êº¼ë‚´ì˜´
```

&nbsp;

## collect()

ìŠ¤íŠ¸ë¦¼ì˜ ìµœì¢… ì—°ì‚° ì¤‘ì—ì„œ ê°€ì¥ ë³µì¡í•œ ê°œë…

`collect()`ëŠ” ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ìˆ˜ì§‘í•˜ëŠ” ìµœì¢… ì—°ì‚°ìœ¼ë¡œ, ì–´ë–»ê²Œ ìˆ˜ì§‘í• ì§€ì— ëŒ€í•œ ë°©ë²•ì€ ì»¬ë ‰í„°ë¡œ ì •í•  ìˆ˜ ìˆìŒ (ì»¬ë ‰í„°ëŠ” ì§ì ‘ êµ¬í˜„í•˜ê±°ë‚˜ `Collectors`ì˜ ë©”ì„œë“œë¡œ ê°€ì ¸ì™€ì„œ ì‚¬ìš©)

> ì»¬ë ‰í„°: `Collector` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤
>
> `Collectors` í´ë˜ìŠ¤ì—ëŠ” ë¯¸ë¦¬ ì“°ì—¬ì§„ ë‹¤ì–‘í•œ ì»¬ë ‰í„°ë¥¼ ë°˜í™˜í•˜ëŠ” static ë©”ì„œë“œ ì¡´ì¬

- Object `collect`(Collector c)

  `Collector`ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ì˜ ê°ì²´ë¥¼ ë°›ì•„ì™€ ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ ìˆ˜ì§‘

- Object `collect`(Supplier s, BiConsumer accumulator, BiConsumer combiner)

  > ì˜ ì‚¬ìš©ë˜ì§€ëŠ” ì•Šì§€ë§Œ, `Collector` êµ¬í˜„ ì—†ì´ ê°„ë‹¨í•˜ê²Œ ëŒë‹¤ì‹ìœ¼ë¡œ í•  ë•Œ ì“¸ ìˆ˜ ìˆìŒ

&nbsp;

### ìŠ¤íŠ¸ë¦¼ì„ ì»¬ë ‰ì…˜ê³¼ ë°°ì—´ë¡œ ë³€í™˜ - toList(), toSet(), toMap(), toCollection(), toArray()

`toList()`, `toSet()`ì€ ìŠ¤íŠ¸ë¦¼ì˜ ëª¨ë“  ìš”ì†Œë¥¼ `List`ì™€ `Set` ì»¬ë ‰ì…˜ì— ë„£ì–´ì¤Œ

ì´ì™¸ì˜ ì¢…ë¥˜ì˜ ì»¬ë ‰ì…˜ì— ë„£ìœ¼ë ¤ë©´ `toCollection()`ì˜ ë§¤ê°œë³€ìˆ˜ì— ì›í•˜ëŠ” ì»¬ë ‰ì…˜ íƒ€ì…ì˜ ìƒì„±ìë¥¼ ë„£ì–´ì£¼ë©´ ë¨ (ë©”ì„œë“œ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ)

```java
Stream<String> strStream = Stream.of("aaa", "bbbbb", "cccccccc");

List<Integer> list = strStream.map(String::length).collect(Collectors.toList());
// List<Integer> list = names.map(String::length).toList();

ArrayList<Integer> arrList = list.stream().collect(Collectors.toCollection(ArrayList::new));
// ArrayList<Integer> arrList = new ArrayList<>(list);
```

&nbsp;

`Map` ì»¬ë ‰ì…˜ì€ key-value ìŒìœ¼ë¡œ ì´ë£¨ì–´ì ¸ìˆê¸° ë•Œë¬¸ì— ì–´ë–¤ ë¶€ë¶„ì€ keyë¡œ í•˜ê³ , ì–´ë–¤ ë¶€ë¶„ì„ valueë¡œ í• ì§€ ì§€ì •í•´ì•¼í•¨

ì´ëŸ´ ë•ŒëŠ” `toMap()`ì„ ì‚¬ìš©

```java
Map<String, Person> map = personStream.collect(Collectors.toMap(p -> p.getId(), p -> p))
```

> `Person` ê°ì²´ì˜ `id` í•„ë“œë¥¼ keyë¡œ ì‚¼ê³ , `Person` ê°ì²´ë¥¼ ê·¸ëŒ€ë¡œ valueë¡œ ì €ì¥í•¨

&nbsp;

ìŠ¤íŠ¸ë¦¼ì— ì €ì¥ëœ ìš”ì†Œë“¤ì„ ë°°ì—´ì— ë‹´ê³ ì í•  ë•ŒëŠ” `toArray()`ë¥¼ ì‚¬ìš©

ì´ ë•Œ, ë§¤ê°œë³€ìˆ˜ì— ìƒì„±í•˜ê³ ì í•˜ëŠ” ë°°ì—´ì˜ íƒ€ì…ì— ë§ê²Œ ìƒì„±ìë¥¼ ë„˜ê²¨ì£¼ì–´ì•¼í•¨

> ìƒì„±ìë¥¼ ì§€ì •í•´ì£¼ì§€ ì•Šìœ¼ë©´ `Object[]` íƒ€ì…ì„ ë°˜í™˜í•¨.

```java
String[] strArr = strStream.toArray(String[]::new);
```

&nbsp;

### í†µê³„ - counting(), summingInt(), averagingInt(), maxBy(), minBy()

`collect()`ë¥¼ í†µí•´ì„œë„ ìŠ¤íŠ¸ë¦¼ ìš”ì†Œì˜ í†µê³„ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆìŒ

`groupingBy()`ì™€ í•¨ê»˜ ì‚¬ìš©í•  ë•Œ ì‹œë„ˆì§€

```java
Stream<Integer> numStream = Stream.of(1, 2, 3, 4, 5);

long count = numStream.collect(Collectors.counting());
// long count = numStream.count();

long sum = numStream.collect(Collectors.summingInt(Integer::intValue));
// long sum = numStream.mapToInt(Integer::intValue).sum();

Optional<Integer> max = numStream.collect(Collectors.maxBy(Integer::compareTo));
// OptionalInt max = numStream.max();

IntSummaryStatistics stats = numStream.collect(Collectors.summarizingInt(Integer::intValue));
// IntSummaryStatistics stats = numStream.mapToInt(Integer::intValue).summaryStatistics();
```

ì£¼ì„ì²˜ë¦¬ëœ ì›ë˜ì˜ ë°©ì‹ì´ í›¨ì”¬ ê°„ê²°í•˜ì§€ë§Œ, `collect()`ì˜ ì‚¬ìš©ë²• ì¤‘ì— í•˜ë‚˜ë¡œì¨ ì„¤ëª…í•œ ê²ƒ

&nbsp;

### ë¦¬ë“€ì‹± - reducing()

`collect()`ë¡œ ë¦¬ë“€ì‹±ë„ ê°€ëŠ¥.

```java
IntStream intStream = new Random().ints(1, 11);

Optional<Integer> max = intStream.boxed().collect(Collectors.reducing(Integer::max));
// OptionalInt max = intStream.reduce(Integer::max);

long sum = intStream.boxed().collect(Collectors.reducing(0, Integer::sum));
// long sum = intStream.reduce(0, Integer::sum);
```

&nbsp;

### ë¬¸ìì—´ ê²°í•© - joining()

ë¬¸ìì—´ ìŠ¤íŠ¸ë¦¼ì˜ ëª¨ë“  ìš”ì†Œë¥¼ í•˜ë‚˜ì˜ ë¬¸ìì—´ë¡œ ì—°ê²°í•´ì„œ ë°˜í™˜

ì¤‘ê°„ì— ë“¤ì–´ê°ˆ êµ¬ë¶„ì ì§€ì • ê°€ëŠ¥, ì ‘ë‘ì‚¬/ì ‘ë¯¸ì‚¬ ì§€ì • ê°€ëŠ¥

ë‹¨, `String`ê³¼ `StringBuffer`ì™€ ê°™ì€ `CharSequence`ì˜ ìì†ë§Œ ê²°í•©ì´ ê°€ëŠ¥í•˜ë¯€ë¡œ ì´ì™¸ì˜ íƒ€ì…ë“¤ì€ ë¬¸ìì—´ë¡œ ë°˜ë“œì‹œ ë³€í™˜ í›„ ì§„í–‰í•´ì•¼í•¨

```java
String studentNames = studentStream.map(Student::getName).collect(joining()); // êµ¬ë¶„ì ì—†ì´
String studentNames = studentStream.map(Student::getName).collect(joining(",")); // êµ¬ë¶„ì ","
```

&nbsp;

### ê·¸ë£¹í™”ì™€ ë¶„í•  - groupingBy(), partitioningBy()

ì§€ê¸ˆê¹Œì§€ ë´ì˜¨ `collect()`ì˜ ì“°ì„ìƒˆëŠ” ê¸°ì¡´ì˜ ë” ê°„ê²°í•œ ì½”ë“œë¡œë„ í‘œí˜„ ê°€ëŠ¥í–ˆê¸° ë•Œë¬¸ì— ì™œ ì“°ëŠ”ì§€ ì˜ë¬¸ì´ ë“¤ ìˆ˜ ìˆìŒ.

ê·¸ë£¹í™”ì™€ ë¶„í• ì—ì„œ `collect()`ì˜ ì§„ê°€ê°€ ë“œëŸ¬ë‚¨

&nbsp;

ê·¸ë£¹í™”: ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ íŠ¹ì • ê¸°ì¤€(`Function`)ì— ì˜í•´ ì—¬ëŸ¬ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒ

- Collector `groupingBy`(Function classifier)

- Collector `groupingBy`(Function classifier, Collector downstream)

- Collector `groupingBy`(Function classifier, Supplier mapFactory, Collector downstream)

ë¶„í• : ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œë¥¼ íŠ¹ì • ì¡°ê±´(`Predicate`)ì„ ë§Œì¡±í•˜ëŠ” ê·¸ë£¹ê³¼ ë§Œì¡±í•˜ì§€ ëª»í•˜ëŠ” ê·¸ë£¹, ì´ë ‡ê²Œ 2ê°€ì§€ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒ

- Collector `partitioningBy`(Predicate predicate)

- Collector `partitioningBy`(Predicate predicate, Collector downstream)

&nbsp;

ìŠ¤íŠ¸ë¦¼ì„ 2ê°œë¡œ ë‚˜ëˆˆë‹¤ë©´ `partitioningBy()`ë¥¼, ê·¸ ì™¸ì—ëŠ” `groupingBy()`ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ íš¨ìœ¨ì 

ê·¸ë£¹í™”ì™€ ë¶„í• ì˜ ê²°ê³¼ëŠ” `Map`ì— ë‹´ê¹€. (key: ê·¸ë£¹ì˜ ê³µí†µ ì†ì„±, value: ìŠ¤íŠ¸ë¦¼ì˜ ìš”ì†Œ)

&nbsp;

ì•„ë˜ `Student` íƒ€ì…ì˜ ìš”ì†Œë¡œ ì´ë£¨ì–´ì§„ ìŠ¤íŠ¸ë¦¼, `Stream<Student>` íƒ€ì…ì˜ `stuStream`ì„ ê°€ì§€ê³  ì§„í–‰.

```java
class Student {
    String name;
    boolean isMale;
    int year;
    int classNum;
    int score;

    Student(String name, boolean isMale, int year, int classNum, int score) {
        this.name = name;
        this.isMale = isMale;
        this.year = year;
        this.classNum = classNum;
        this.score = score;
    }

    String getName() { return name; }
    boolean isMale() { return isMale; }
    int getYear() { return year; }
    int getClassNum() { return classNum; }
    int getScore() { return  score; }

    public String toString() {
        return String.format("Name: %s, Gender: %s, Year: %d, Class: %d, Score: %d", name, isMale ? "Male" : "Female", year, classNum, score);
    }

    enum Level { HIGH, INTERMEDIATE, LOW}
}
```

&nbsp;

### partitioningBy()ì— ì˜í•œ ë¶„ë¥˜

1. ê¸°ë³¸ ë¶„í• 

   ex) ì„±ë³„ì— ë”°ë¼ ë¶„ë¥˜í•˜ê¸°

   ```java
   Map<Boolean, List<Student>> stuByGender = stuStream.collect(Collectors.partitioningBy(Student::isMale));

   List<Student> maleStudents = stuByGender.get(true);
   List<Student> femaleStudents = stuByGender.get(false);
   ```

&nbsp;

2. ê¸°ë³¸ ë¶„í•  + í†µê³„

   ex) ë‚¨í•™ìƒì˜ ìˆ˜ì™€ ì—¬í•™ìƒì˜ ìˆ˜ êµ¬í•˜ê¸°

   ```java
   Map<Boolean, Long> stuByGender = stuStream.collect(Collectors.partitioningBy(Student::isMale, Collectors.counting()));

   Long maleStudentsNum = stuByGender.get(true);
   Long femaleStudentsNum = stuByGender.get(false);
   ```

   &nbsp;

   ex2) ë‚¨í•™ìƒê³¼ ì—¬í•™ìƒ ê·¸ë£¹ì—ì„œ ê°ê° ìµœê³  ì ìˆ˜ë¥¼ ì–»ì€ ì‚¬ëŒ êµ¬í•˜ê¸°

   ```java
   Map<Boolean, Optional<Student>> topScoreByGender = stuStream.collect(
           Collectors.partitioningBy(Student::isMale,
                   Collectors.maxBy(
                           Comparator.comparingInt(
                                   Student::getScore
                           )
                   )
           )
   );

   System.out.println("Male Top Scorer: " + topScoreByGender.get(true));
   System.out.println("Female Top Scorer: " + topScoreByGender.get(false));
   ```

   > ìœ„ ì˜ˆì‹œì—ì„œëŠ” ë°˜í™˜íƒ€ì…ì´ `Optional<Student>`ë¡œ ë‚˜ì˜¤ê²Œ ë˜ëŠ”ë°, ë°˜í™˜íƒ€ì…ì„ `Student`ë¡œ ë°›ê³  ì‹¶ë‹¤ë©´
   >
   > `collectingAndThen()`ì„ ì‚¬ìš©í•´ì„œ, `maxBy()` ìˆ˜í–‰ ì´í›„ `get()`ìœ¼ë¡œ `Optionalì— ì €ì¥ëœ ê°’ì„ ê°€ì ¸ì˜¤ê² ë‹¤ê³  ëª…ì‹œí•˜ë©´ ë¨
   >
   > ```java
   > Map<Boolean, Student> topScoreByGender = stuStream.collect(
   >         Collectors.partitioningBy(Student::isMale,
   >                 Collectors.collectingAndThen(
   >                         Collectors.maxBy(Comparator.comparingInt(Student::getScore)), Optional::get
   >                 )
   >         )
   > );
   > ```

&nbsp;

`partitioningBy()`ì€ `Collector` íƒ€ì…ì„ ë°˜í™˜í•˜ëŠ”ë°, ìì‹ ì˜ ë‘ë²ˆì§¸ ë§¤ê°œë³€ìˆ˜ì¸ `downstream`ë„ `Collector` íƒ€ì…ì´ë¯€ë¡œ ì¬ê·€ í˜¸ì¶œ í•˜ë“¯ì´ `partitioningBy()`ë¥¼ ì¤‘ì²©í•  ìˆ˜ ìˆìŒ

&nbsp;

3. ì´ì¤‘ ë¶„í• 

   ex) ë¶ˆí•©ê²© ì²˜ë¦¬ë¥¼ ìœ„í•´, ì„±ì ì´ 80ì  ì´í•˜ì¸ í•™ìƒë“¤ì„ ì„±ë³„ ê·¸ë£¹ë³„ë¡œ êµ¬í•˜ê¸°

   ```java
   Map<Boolean, Map<Boolean, List<Student>>> failedStuByGender = stuStream.collect(
           Collectors.partitioningBy(Student::isMale,
                   Collectors.partitioningBy(s -> s.getScore() < 80)
           )
   );

   List<Student> maleStudents = failedStuByGender.get(true).get(true);
   List<Student> femaleStudents = failedStuByGender.get(false).get(true);
   ```

&nbsp;

### groupingBy()ì— ì˜í•œ ë¶„ë¥˜

ex) ë°˜ë³„ ê·¸ë£¹ìœ¼ë¡œ ë‚˜ëˆ„ê¸°

```java
Map<Integer, List<Student>> stuByClassNum = stuStream.collect(Collectors.groupingBy(Student::getClassNum));
// Map<Integer, List<Student>> stuByClassNum = stuStream.collect(Collectors.groupingBy(Student::getClassNum, toList()));
```

`groupingBy()`ë¡œ ê·¸ë£¹í™”í•˜ë©´ ê° ê·¸ë£¹ì˜ ìš”ì†Œë“¤ì€ `List<T>` íƒ€ì…ì— ë‹´ê¸°ì§€ë§Œ,

ìƒëµëœ `toList()` ëŒ€ì‹ ì— `toSet()`, `toCollection(HashSet::new)`ì™€ ê°™ì´ ë‹¤ë¥¸ íƒ€ì…ì˜ ì»¬ë ‰ì…˜ì— ë‹´ì•„ë‚¼ ìˆ˜ ìˆìŒ.

> ë‹¹ì—°íˆ ì¢Œë³€ `Map`ì˜ ì œë„¤ë¦­ íƒ€ì…ë„ ê·¸ì— ë§ê²Œ ìˆ˜ì •ì´ í•„ìš”í•¨

&nbsp;

ex2) ì„±ì  ë“±ê¸‰(Student.Level ì—´ê±°í˜•)ìœ¼ë¡œ ë‚˜ëˆ„ê¸°

80ì  ì´ìƒì„ `HIGH`, 60ì  ì´ìƒì„ `INTERMEDIATE`, ê·¸ ì™¸ëŠ” `LOW`ë¡œ ë¶„ë¥˜í•¨

```java
Map<Student.Level, Long> stuByLevel = stuStream.collect(
        Collectors.groupingBy(s -> {
            if (s.getScore() >= 90) return Student.Level.HIGH;
            else if (s.getScore() >= 60) return Student.Level.INTERMEDIATE;
            else return Student.Level.LOW;
        }, Collectors.counting())
);
```

&nbsp;

`partitioningBy()`ì²˜ëŸ¼ `groupingBy()`ë„ ì¤‘ì²©ì´ ê°€ëŠ¥í•¨. (= ê·¸ë£¹ì„ ì¢€ ë” ì„¸ë¶„í™”í•˜ì—¬ ë‚˜ëˆ„ê¸°)

ex3) í•™ë…„ ë³„ë¡œ ê·¸ë£¹í™” í•œ ë‹¤ìŒ, ê·¸ ì•ˆì—ì„œ ë°˜ ë³„ë¡œ ê·¸ë£¹í™” í•˜ê¸°

```java
Map<Integer, Map<Integer, List<Student>>> stuByYearAndClassNum = stuStream.collect(
        Collectors.groupingBy(Student::getYear,
                Collectors.groupingBy(Student::getClassNum)
        )
);
```

ex4) ex3ë¡œ ê·¸ë£¹í™”í•œ ìƒíƒœì—ì„œ ê° ë°˜ì˜ ìµœê³  ì ìˆ˜ë¥¼ ì–»ì€ ì‚¬ëŒ êµ¬í•˜ê¸°

```java
Map<Integer, Map<Integer, Student>> stuByYearAndClassNum = stuStream.collect(
        Collectors.groupingBy(Student::getYear,
                Collectors.groupingBy(Student::getClassNum,
                        Collectors.collectingAndThen(Collectors.maxBy(
                                Comparator.comparingInt(Student::getScore)
                        ), Optional::get)
                )
        )
);
```
