# 컬렉션 프레임웍 (Collections Framework)

다수의 데이터(Collection)를 다루는 클래스의 표준 설계(Framework)

`JDK` 1.2부터 도입됨

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200811210521/Collection-Framework-1.png)

&nbsp;

## 컬렉션 프레임웍의 핵심 인터페이스

컬렉션에는 3가지 타입이 존재 (List, Set, Map)

이들 각각을 다루는데에 필요한 기능을 `List`, `Set`, `Map` 인터페이스로 정의함.

이 중에서 `List`와 `Set`은 공통적인 부분이 많아서 상위 인터페이스로 `Collection`을 만들고 거기에 공통 기능들을 넣었음.

| 인터페이스 | <center>특징</center>                                                                                      | <center>구현 클래스</center>                    |
| :--------: | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
|   `List`   | - 순서가 있는 데이터의 집합<br/>- 데이터의 중복 허용                                                       | `ArrayList`, `LinkedList`, `Stack`, `Vector`    |
|   `Set`    | - 순서가 유지되지 않는 데이터의 집합<br/>- 데이터의 중복 불허                                              | `HashSet`, `TreeSet`                            |
|   `Map`    | - key와 value의 쌍으로 이루어진, 순서가 유지되지 않는 데이터의 집합<br/>- key 중복 불허, value 중복은 허용 | `HashMap`, `TreeMap`, `Hashtable`, `Properties` |

&nbsp;

> 구현 클래스의 네이밍을 보면 자신이 구현한 인터페이스의 이름을 포함하고 있음
>
> `Stack`, `Vector`, `Hashtable`, `Properties`는 컬럭션 프레임웍이 등장하기 이전부터 있었기 때문에 네이밍 컨벤션을 따르지 않음.

> 가능하면 구형 컬렉션인 `Vector` 대신 `ArrayList`를, `Hashtable` 대신 `HashMap`을 사용하는 것이 좋음

&nbsp;

### Collection 인터페이스

`List`와 `Set` 인터페이스의 조상.

컬렉션 클래스에 저장된 데이터 읽기, 추가하기, 삭제하기 등의 기본적인 기능 정의

&nbsp;

### Map.Entry 인터페이스

`Map` 인터페이스의 내부 인터페이스로, 저장되어있는 key-value쌍을 다루기 위한 용도.

따라서 `Map`을 구현하는 클래스에서는 `Map.Entry`도 같이 구현해야함

```java
public interface Map {
    ...
    public static interface Entry {
        Object getKey();
        Object getValue();
        Object setValue();
        boolean equals(Object o);
        int hashCode();
        ...
    }
}
```

&nbsp;

## ArrayList

기존의 `Vector`를 개선한 것이기 때문에 기능적으로는 동일.

> `Vector`는 레거시 호환 차원에서 남겨놓은 것이므로 되도록 `ArrayList` 사용 권장

`Object` 배열에 데이터를 0번 인덱스부터 순차적으로 저장함. (기본 배열 크기: 10)

저장 공간이 가득 차면, 더 큰 용량의 `Object` 배열을 생성해서 그쪽으로 데이터를 전부 복사하고, 마저 저장 작업을 함.

예시1) 기본 메서드 활용

```java
class ArrayListExample {
    public static void main(String[] args) {
        ArrayList l1 = new ArrayList();
        l1.add(3);
        l1.add(1);
        l1.add(5);
        l1.add(4);
        l1.add(2); // l1: [3, 1, 5, 4, 2]

        ArrayList l2 = new ArrayList(l1.subList(1, 4)); // l2: [1, 5, 4]

        Collections.sort(l1); // l1: [1, 2, 3, 4, 5]
        Collections.sort(l2); // l2: [1, 4, 5]

        System.out.println(l1.containsAll(l2)); // true

        l2.set(2, "A"); // l2: [1, 4, "A"]

        l1.retainAll(l2); // l1: [1, 4]

        for (int i = (l2.size() - 1); i >= 0; i--) {
            if (l1.contains(l2.get(i))) l2.remove(i);
        }

        System.out.println(l2); // ["A"]
    }
}
```

> `for`문에서 i를 0부터 증가시켜가며 삭제하면, 요소가 삭제될 때마다 배열 원소들이 당겨지면서 올바른 결과를 얻을 수 없게 되므로, i의 최대값부터 내려오면서 돌아야함

&nbsp;

예시2) 문자열을 특정 단위만큼씩 잘라서 배열에 넣기

```java
class ArrayListExample2 {
    public static void main(String[] args) {
        final int LIMIT = 10; // 10개씩 자를 예정
        String source = "1234567890abcdefghijABCDEFGHIJZZZ";
        int length = source.length();

        ArrayList list = new ArrayList(length / LIMIT + 10); // 배열의 길이를 넉넉하게 잡고 시작

        for (int i = 0; i < length; i += LIMIT) {
            if (i + LIMIT < length) {
                list.add(source.substring(i, i + LIMIT)); // i부터 (i + LIMIT) 인덱스까지 잘라서 list에 추가
            } else {
                list.add(source.substring(i)); // i부터 맨끝 인덱스까지 잘라서 list에 추가
            }
        }

        System.out.println(list); // [1234567890, abcdefghij, ABCDEFGHIJ, ZZZ]
}
```

> 📌 [주의] `ArrayList`를 생성할 때 크기를 여유있게 만드는 것이 좋음.
>
> 작업 도중 공간이 부족하면 크기를 알아서 늘려주기는 하지만, 이 과정에서 처리시간이 불필요하게 소모되기 때문

&nbsp;

## LinkedList

앞서 살펴보았던 `ArrayList`의 단점을 먼저 짚어보자.

1. 크기 변경 불가

   - 원하는 크기의 새로운 인스턴스를 생성하여 그곳에 모든 데이터를 붙여넣는 식으로만 크기 변경 가능

   - 성능 이슈를 감안해 처음부터 넉넉한 크기로 생성해버리면, 남는 공간이 생겨 메모리가 낭비될 수 있음

2. 비순차적 데이터의 추가와 삭제 작업이 비효율적임

   - 배열의 중간에 데이터를 추가하거나 삭제할 때, 해당 자리 뒤의 원소들을 모두 복사해서 한칸 밀거나 당겨 붙여넣는 작업이 이루어지므로 비효율적.

&nbsp;

이러한 단점을 보완하기 위해 나온 것이 **Linked List**.

배열은 모든 데이터가 연속적으로 존재하지만, **Linked List**는 불연속적으로 존재하는 데이터를 연결한 구조.

**Linked List**의 각 요소(node)는 데이터와 함께 자신과 연결된 다음 node의 주소값을 가지고 있음.

```java
class Node {
    Node next; // 다음 노드의 주소값
    Object obj; // 데이터
}
```

&nbsp;

**Linked List**에서 요소를 추가하거나 삭제하는 프로세스는 매우 간단함.

1. 요소 추가

   추가할 위치의 이전 Node가 신규 Node를 참조하게 하고, 신규 Node가 추가할 위치 다음의 Node를 참조하게 만들면 됨.

   > 추가 전: prevNode --------------------> nextNode
   >
   > 추가 후: prevNode ----> newNode ----> nextNode

2. 요소 삭제

   삭제하고자 하는 node의 이전 node가 삭제하고자 하는 node의 다음 node를 참조하게 만들면 됨

   > 삭제 전: prevNode ---> targetNode ---> nextNode
   >
   > 삭제 후: prevNode --------------------> nextNode

&nbsp;

**Linked List**는 이동 방향이 단방향이라서 다음 Node 접근은 쉽지만, 이전 Node 접근은 어려움

이를 보완한 **Doubly Linked List**는 Node 안에 다음 Node의 주소값 뿐만 아니라, 이전 Node의 주소값도 저장함.

`LinkedList`는 이름과는 다르게 실제로는 이 **Doubly Linked List**로 구현되어 있음

```java
class Node {
    Node next; // 다음 노드 주소값
    Node previous; // 이전 노드 주소값
    Object obj; // 데이터
}
```

여기서 한 발 더 나아가 **Doubly Linked List**의 접근성을 더 향상시킨 것이 **Doubly Circular Linked List**임

이름의 circular에서 짐작할 수 있듯, 순환 구조를 띄고 있어 마지막 Node가 첫번째 Node의 주소값을 가지고 있고, 첫번째 Node도 마지막 Node의 주소값을 가지고 있음

> 원래의 Linked List나 Doubly Linked List에서는 순환 구조가 아니므로 해당 값들이 `null`임

&nbsp;

(메서드 전체는 교재 p.598 참고)

`LinkedList`의 메서드 중 `element()`와 `peek()`은 모두 첫번째 요소를 반환함.

단, 리스트가 비어있을 때 `element()`는 `NoSuchElementException`을 던짐

따라서 리스트가 비어있으면 안되는 경우라면 `element()`를 써서 fail fast 하는게 나음

> 이처럼 메서드 중에는 같은 기능을 하는 것들이 있는데, 그 중에서 작업 실패시 예외를 던지는 메서드를 사용하는 것이 디버깅 측면에서는 안전함.

&nbsp;

👨‍💻 `ArrayList`와 `LinkedList` 성능 테스트

예시)

```java
import java.util.*;

class LinkedListExample {
    public static void main(String[] args) {
        ArrayList al = new ArrayList(2000000);
        LinkedList ll = new LinkedList();

        System.out.println("---순차적으로 추가하기---");
        System.out.println("ArrayList: " + add1(al) + "ms");
        System.out.println("LinkedList: " + add1(ll) + "ms");

        System.out.println("---중간에 추가하기---");
        System.out.println("ArrayList: " + add2(al) + "ms");
        System.out.println("LinkedList: " + add2(ll) + "ms");

        System.out.println("---순차적으로 삭제하기---");
        System.out.println("ArrayList: " + remove1(al) + "ms");
        System.out.println("LinkedList: " + remove1(ll) + "ms");

        add1(al);
        add1(ll);

        System.out.println("---중간에 삭제하기---");
        System.out.println("ArrayList: " + remove2(al) + "ms");
        System.out.println("LinkedList: " + remove2(ll) + "ms");
    }

    public static long add1(List list) {
        long start = System.currentTimeMillis();
        for(int i = 0; i < 1000000; i++) list.add(i);
        long end = System.currentTimeMillis();
        return (end - start);
    }

    public static long add2(List list) {
        long start = System.currentTimeMillis();
        for(int i = 0; i < 10000; i++) list.add(500, i);
        long end = System.currentTimeMillis();
        return (end - start);
    }

    public static long remove1(List list) {
        long start = System.currentTimeMillis();
        for(int i = (list.size() - 1); i >= 0; i--) list.remove(i);
        long end = System.currentTimeMillis();
        return (end - start);
    }

    public static long remove2(List list) {
        long start = System.currentTimeMillis();
        for(int i = 0; i < 10000; i++) list.remove(i);
        long end = System.currentTimeMillis();
        return (end - start);
    }
}
```

실행 결과)

    ---순차적으로 추가하기---
    ArrayList: 23ms
    LinkedList: 147ms
    ---중간에 추가하기---
    ArrayList: 2478ms
    LinkedList: 9ms
    ---순차적으로 삭제하기---
    ArrayList: 6ms
    LinkedList: 18ms
    ---중간에 삭제하기---
    ArrayList: 1249ms
    LinkedList: 100ms

테스트 결과로 다음과 같은 결론을 얻음.

1. 데이터를 순차적으로 추가/삭제하는 경우 `ArrayList`가 더 빠름

   > 단, 여기서는 저장 속도만 비교하기 위해 처음에 `ArrayList`에 충분한 크기를 지정해줬음.
   >
   > 만약 크기 지정 없이 진행했으면 반복적으로 새 인스턴스를 생성하게 되어 속도가 `LinkedList`보다 느려질 수도 있음

2. 데이터를 중간에 추가/삭제하는 경우 `LinkedList`가 더 빠름

&nbsp;

`ArrayList`와 `LinkedList`가 데이터를 읽어오는 방식에 대해서 살펴보자

`ArrayList`는 데이터가 저장된 메모리 주소가 연속적이기 때문에 index만 주어지면 곧바로 주소값을 도출할 수 있음. 즉, 첫번째 요소부터 순서대로 다 훑지 않아도 됨.

반면, `LinkedList`는 데이터가 저장 위치가 불연속적이라서 link를 따라 첫번째 요소부터 순서대로 따라가야만 n번째 요소에 접근할 수 있음.

따라서 읽기 작업에 있어서는 전체 데이터 개수가 많으면 많을수록 `LinkedList`가 성능이 떨어짐.

&nbsp;

## Stack과 Queue

Stack: Last-In-First-Out(LIFO)

Queue: First-In-First-Out(FIFO)

위의 특성을 고려했을 때, Stack은 데이터를 순차적으로 추가하고 삭제할 수 있는 `ArrayList`가 적합.

그러나 Queue의 경우는 첫번째 요소부터 빠져나가는 구조이므로 `ArrayList`로 구현할 시, 매번 요소들의 자리 이동이 발생하여 비효율적. 따라서 `LinkedList`가 적합.

&nbsp;

👨‍💻 Stack과 Queue의 메서드를 활용한 요소 삽입 및 제거

예시)

```java
Stack s = new Stack();
Queue q = new LinkedList(); // Queue 인터페이스의 구현 클래스

s.push(1);
s.push(2);
s.push(3);

q.offer(1);
q.offer(2);
q.offer(3);

System.out.println("---Stack---");
while (!s.isEmpty()) {
    System.out.println(s.pop());
}

System.out.println("---Queue---");
while (!q.isEmpty()) {
    System.out.println(q.poll());
}
```

실행 결과)

    ---Stack---
    3
    2
    1
    ---Queue---
    1
    2
    3

> `Stack`은 별도 클래스가 존재하지만, `Queue`는 인터페이스로만 존재하므로 `Queue`를 구현한 클래스인 `LinkedList`를 사용

&nbsp;

### Stack 직접 구현하기

`Stack`은 컬렉션 프레임웍 이전부터 존재했기 때문에 `Vector`로부터 상속을 받음.

실제 `Stack`을 단순화하여 구현해보면 다음과 같음.

> `Vector`에 구현된 메서드인 `addElement()`, `removeElement()`, `elementAt()`, `size()`, `lastIndexOf()` 사용

```java
class MyStack extends Vector {
        public Object push(Object item) {
                addElement(item);
                return item;
        }

        public Object pop() {
                Object obj = peek();
                removeElementAt(size() - 1);
                return obj;
        }

        public Object peek() {
                if (size() == 0) throw new EmptyStackException();
                return elementAt(size() - 1);
        }

        public boolean empty() {
                return size() == 0;
        }

        public int search(Object o) {
                int i = lastIndexOf(o);
                if (i >= 0) return (size() - i);
                return -1;
        }
}
```

> 📌 [주의] `Stack`은 (가장 나중에 들어온) 맨 뒤의 요소부터 index 1로 간주하기 때문에 `search()` 메서드에서 반환하는 index는 앞에서부터 센 `i`가 아닌 `size() - i` 가 됨.

&nbsp;

### PriorityQueue

`Queue` 인터페이스의 구현체 중 하나.

저장 순서와 상관 없이 우선 순위(priority)가 높은 것부터 꺼냄

- `null` 저장 불가 (`NullPointerException`)

- 저장 공간으로 배열 활용

- 요소를 heap 형태로 저장

  > heap은 최대값, 최소값을 빠르게 찾을 수 있는 구조이므로, 저장된 값의 크기에 따라 우선순위를 매기는 `PriorityQueue`에게 적합한 저장 방식

```java
class PriorityQueueExample {
    public static void main(String[] args) {
        PriorityQueue pq = new PriorityQueue();
        pq.offer(4);
        pq.offer(1);
        pq.offer(5);
        pq.offer(3);
        pq.offer(2);
        System.out.println(pq);

        Object obj = null;
        while ((obj = pq.poll()) != null) { // pq의 요소를 맨앞에서부터 하나씩 빼서 obj에 할당하고 출력
            System.out.println(obj);
        }
    }
}
```

실행 결과)

    [1, 2, 5, 4, 3]
    1
    2
    3
    4
    5

4, 1, 5, 3, 2 순서로 저장했는데 [1, 2, 5, 4, 3]으로 출력된 이유는 `PriorityQueue`의 자료구조가 heap이기 때문.

> heap은 이진 트리 방식이므로 1 밑으로 2, 5가 오고, 다시 2 밑으로 4, 3이 왔다고 보면 됨

그리고 개별 원소를 하나씩 `poll()`로 빼낼 때는 숫자가 작을수록 우선순위가 높기 때문에 값이 낮은 순서대로 나왔음

> 만약 숫자가 아니고 객체를 요소로 갖고 있었다면, 객체 간의 크기를 비교할 방식을 제시해주어야함.
>
> 예시에서는 숫자를 넣어서 컴파일러가 `Integer`로 auto-boxing 해주었고, 자체적으로 비교 방식이 정의되어 있기 때문에 별도로 비교 방식을 제시해줄 필요가 없었던 것.

&nbsp;

### Deque(Double-Ended Queue)

`Queue`의 자손 인터페이스 (구현체: `ArrayDeque`, `LinkedList`)

`Queue`가 한쪽 방향으로만 추가 및 삭제가 가능한 반면, `Deque`는 양방향으로 추가 및 삭제가 가능.

사실상 Stack과 Queue의 기능을 모두 할 수 있는 존재

> `Java` 공식 문서에서는 `Stack`을 레거시로 취급하고, `Stack`보다는 `Deque`를 활용할 것을 권장함.

&nbsp;

👨‍💻 `Deque`를 `Stack`처럼 사용하기

```java
class DequeExample {
    public static void main(String[] args) {
        Deque d = new ArrayDeque();
        d.offerLast(1);
        d.offerLast(2);
        d.offerLast(3);

        System.out.println(d);

        System.out.println(d.pollLast());
        System.out.println(d.pollLast());
        System.out.println(d.pollLast());

        System.out.println(d);
    }
}
```

실행 결과)

    [1, 2, 3]
    3
    2
    1
    []

&nbsp;

👨‍💻 `Deque`를 `Queue`처럼 활용하기

```java
class DequeExample {
        public static void main(String[] args) {
                Deque d = new ArrayDeque();
                d.offerLast(1);
                d.offerLast(2);
                d.offerLast(3);

                System.out.println(d);

                System.out.println(d.pollFirst());
                System.out.println(d.pollFirst());
                System.out.println(d.pollFirst());

                System.out.println(d);
        }
}
```

실행 결과)

    [1, 2, 3]
    1
    2
    3
    []

> 만약 `offerFirst()`에 `pollLast()`로 하면 반대 방향의 Queue가 됨
