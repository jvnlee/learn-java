# 컬렉션 프레임웍 (Collections Framework)

다수의 데이터(Collection)를 다루는 클래스의 표준 설계(Framework)

`JDK` 1.2부터 도입됨

&nbsp;

## 컬렉션 프레임웍의 핵심 인터페이스

컬렉션에는 3가지 타입이 존재 (List, Set, Map)

이들 각각을 다루는데에 필요한 기능을 `List`, `Set`, `Map` 인터페이스로 정의함.

이 중에서 `List`와 `Set`은 공통적인 부분이 많아서 상위 인터페이스로 `Collection`을 만들고 거기에 공통 기능들을 넣었음.

| 인터페이스 | <center>특징</center>                                                                                      | <center>구현 클래스</center>                    |
| :--------: | ---------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
|   `List`   | - 순서가 있는 데이터의 집합<br/>- 데이터의 중복 허용                                                       | `ArrayList`, `LinkedList`, `Stack`, `Vector`    |
|   `Set`    | - 순서가 유지되지 않는 데이터의 집합<br/>- 데이터의 중복 불허                                              | `HashSet`, `TreeSet`                            |
|   `Map`    | - key와 value의 쌍으로 이루어진, 순서가 유지되지 않는 데이터의 집합<br/>- key 중복 불허, value 중복은 허용 | `HashMap`, `TreeMap`, `Hashtable`, `Properties` |

&nbsp;

> 구현 클래스의 네이밍을 보면 자신이 구현한 인터페이스의 이름을 포함하고 있음
>
> `Stack`, `Vector`, `Hashtable`, `Properties`는 컬럭션 프레임웍이 등장하기 이전부터 있었기 때문에 네이밍 컨벤션을 따르지 않음.

> 가능하면 구형 컬렉션인 `Vector` 대신 `ArrayList`를, `Hashtable` 대신 `HashMap`을 사용하는 것이 좋음

&nbsp;

### Collection 인터페이스

`List`와 `Set` 인터페이스의 조상.

컬렉션 클래스에 저장된 데이터 읽기, 추가하기, 삭제하기 등의 기본적인 기능 정의

&nbsp;

### Map.Entry 인터페이스

`Map` 인터페이스의 내부 인터페이스로, 저장되어있는 key-value쌍을 다루기 위한 용도.

따라서 `Map`을 구현하는 클래스에서는 `Map.Entry`도 같이 구현해야함

```java
public interface Map {
    ...
    public static interface Entry {
        Object getKey();
        Object getValue();
        Object setValue();
        boolean equals(Object o);
        int hashCode();
        ...
    }
}
```

&nbsp;

## ArrayList

기존의 `Vector`를 개선한 것이기 때문에 기능적으로는 동일.

> `Vector`는 레거시 호환 차원에서 남겨놓은 것이므로 되도록 `ArrayList` 사용 권장

`Object` 배열에 데이터를 0번 인덱스부터 순차적으로 저장함. (기본 배열 크기: 10)

저장 공간이 가득 차면, 더 큰 용량의 `Object` 배열을 생성해서 그쪽으로 데이터를 전부 복사하고, 마저 저장 작업을 함.

```java
class ArrayListExample {
    public static void main(String[] args) {
        ArrayList l1 = new ArrayList();
        l1.add(3);
        l1.add(1);
        l1.add(5);
        l1.add(4);
        l1.add(2); // l1: [3, 1, 5, 4, 2]

        ArrayList l2 = new ArrayList(l1.subList(1, 4)); // l2: [1, 5, 4]

        Collections.sort(l1); // l1: [1, 2, 3, 4, 5]
        Collections.sort(l2); // l2: [1, 4, 5]

        System.out.println(l1.containsAll(l2)); // true

        l2.set(2, "A"); // l2: [1, 4, "A"]

        l1.retainAll(l2); // l1: [1, 4]

        for (int i = (l2.size() - 1); i >= 0; i--) {
            if (l1.contains(l2.get(i))) l2.remove(i);
        }

        System.out.println(l2); // ["A"]
    }
}
```

> `for`문에서 i를 0부터 증가시켜가며 삭제하면, 요소가 삭제될 때마다 배열 원소들이 당겨지면서 올바른 결과를 얻을 수 없게 되므로, i의 최대값부터 내려오면서 돌아야함
