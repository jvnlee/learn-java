# 기본형 (Primitive Type)

## 1. 논리형 (boolean)

`true` 또는 `false` 둘 중 하나의 값만 가지기 때문에 1 bit로도 표현할 수 있지만, `Java`에서의 데이터 최소단위가 1 byte이기 때문에 `boolean`의 크기도 1 byte가 된다.

```java
boolean isLoggedIn = true;
```

&nbsp;

## 2. 문자형 (char)

문자 1개를 저장하기 위한 변수를 선언할 때 사용된다. 정확하게는 문자 자체가 아닌 문자의 유니코드(int 타입)가 저장된다. 크기는 2 byte이다.

```java
char letter = 'A'; // 내부적으로는 'A'의 유니코드 값인 65 라는 정수가 저장된다.
```

```java
char letter = 65; // 저장하고자 하는 문자의 유니코드를 직접 할당 가능
```

&nbsp;

## 3. 정수형 (byte, short, int, long)

어떤 진법의 리터럴을 변수에 저장해도 결국 실제로는 메모리에 2진수로 바뀌어 저장된다. 모든 정수형은 부호(양수, 음수)가 있으므로 맨 왼쪽 비트를 "부호 비트"로 사용한다.

&nbsp;

`byte`나 `short`보다 **`int`를 사용하는 것이 권장**된다. 각 타입이 커버하는 수의 범위를 정확하게 계산해서 사용하면 문제가 없지만 연산 결과가 범위 밖으로 넘어가게 되면 잘못된 결과를 얻을 수 있다.

`JVM`의 피연산자 스택이 피연산자를 4 byte 단위로 저장하기 때문에 그 이하의 크기를 가진 `byte`나 `short`은 연산 전에 4 byte로 변환 과정을 거쳐야 한다.
그래서 성능적으로 봤을 때도 오히려 `int`를 택하는 것이 낫다.

`int`는 약 +-20억 정도의 수를 커버하므로 대부분의 케이스는 `int`를, 혹여나 그보다 더 큰 수를 사용한다면 `long`을 쓰면 된다.

&nbsp;

> **오버플로우 (overflow)** <br /> 4비트 2진수 1111과 0001을 더하면 10000 이 되면서 자리수가 넘어가는데 이 때 하위 4자리만 저장되므로 결과는 0000 이 된다. 이렇게 연산으로 인해 최대 자리수를 초과하는 것을 오버플로우라고 한다.

_부호 있는 정수는 "부호 비트" 즉 가장 좌측의 비트가 0에서 1, 또는 1에서 0으로 바뀔 때 오버플로우가 발생한다._

&nbsp;

## 4. 실수형 (float, double)

정수형과는 다르게 실수형은 정밀도 이슈가 존재한다. `float` 같은 경우는 정밀도가 7인데 이는 7자리의 10진수를 오차 없이 저장 가능하다는 의미이다.

8자리 ~ 15자리는 `double` 타입으로 해야 오차 없이 값을 저장할 수 있다. 따라서 값의 범위 때문보다는 높은 정밀도 때문에 `double`을 일반적으로 채택해서 사용한다.
